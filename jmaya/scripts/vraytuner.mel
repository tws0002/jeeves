//V-Ray Tuner v3.4.2 by Dave Girard (www.can-con.ca)
//email any comments or suggestions to daveg@can-con.ca

global proc materialThresholder()
{
string $allMats[] = `ls -type "VRayMtl"`;
for ($n=0 ; $n<size($allMats) ; $n++)
	{
	setAttr ($allMats[$n] + ".cutoffThreshold") 0.002;
	}
}

global proc revertToSaved()
{
string $resulert = `confirmDialog -title "Confirm" -message "Revert to Saved?" 
     -button "Yes" -button "No" -defaultButton "Yes" 
     -cancelButton "No" -dismissString "No"`;

if ($resulert == "Yes") {
 string $currentScenePath = `file -q -sn`;
file -f -open $currentScenePath;
} else warning "Revert cancelled\n";
}


global proc materialSwapper()
{
global int $keepMatsFinished;

if ( `window -exists materialSwapperUI` )
  deleteUI -window materialSwapperUI;
string $materialSwapperUI = `window -sizeable 0 -title "Material Swapper" materialSwapperUI`;
columnLayout -adjustableColumn true -columnAttach "both" 8;
columnLayout;
separator -style "none" -h 12;
checkBox -l "Keep Original Mats" -v true materialSwapperUICheckbox1;
//checkBox -l "Flip Opacity Map" -v true materialSwapperUICheckbox2;
separator -style "none" -h 4;
button -w 240 -h 30 -l "Material Swapper" -ann "."-c "materialSwapperProc;";
setParent ..;
separator -style "none" -w 240 -h 12;
showWindow $materialSwapperUI;
//read the current menu setting to initialize the Sphere variable 
}

global proc materialSwapperProc()
{
global int $keepMatsFinished;
$keepMatsFinished = `checkBox -q -v materialSwapperUICheckbox1`;
string $mySelection[];
$mySelection = `ls -sl -dag -shapes`;
//if selection is a mesh
string $typeChecker[] = `ls -showType $mySelection`;
if ($typeChecker[1] == "mesh") 
	{
	error "Requires a single material selection.\n";
	}
////loop for materials start
else if ($typeChecker[1] != "mesh") 
	{
	string $currentSurfaceShader[] = `ls -sl`;
	string $currentSurfaceShaderSG[] = `listConnections -s 0 -d 1 -type "shadingEngine"`;
	string $currentSurfaceShaderDisplace[] = `listConnections -s 1 -d 0 ($currentSurfaceShaderSG[0] + ".displacementShader")`;
	for ($n=0 ; $n<size($currentSurfaceShader) ; $n++)
		{
		select -r $currentSurfaceShader[$n];
		string $selectedMatType[] = `ls -sl -showType`;
		string $MayaSWShader;
		string $VRayShader;

		if ($selectedMatType[1] == "VRayMtl")//do Maya SW shader
			{
			int $VRayMatType = `getAttr ($currentSurfaceShader[$n] + ".brdfType")`;//Ward: 2

			switch($VRayMatType) 
					{
				   case 2:
					  $MayaSWShader = "lambert";
					  break;
				   case 1:
					  $MayaSWShader = "blinn";
					  break;
				   case 0:
					  $MayaSWShader = "phong";
					  break;
				   }
				string $newSWShader = `shadingNode -asShader $MayaSWShader -name ($currentSurfaceShader[$n] + "_" + $MayaSWShader)`; 
				select -d;
				rename $newSWShader ($currentSurfaceShader[$n] + "_" + $MayaSWShader);
				//select parent objects and assign
				hyperShade -objects $currentSurfaceShader[$n];
				hyperShade -assign $newSWShader;
				//get new parent SG for created shader
				string $newSurfaceShaderSG[] = `listConnections -s 0 -d 1 -type "shadingEngine" $newSWShader`;
				//if displacement wasn't empty, attach it to new mat
				if ($currentSurfaceShaderDisplace[0] != "");
					{
					//connectAttr "displacementShader1.displacement" "phong1SG.displacementShader";
					connectAttr ($currentSurfaceShaderDisplace[0] + ".displacement") ($newSurfaceShaderSG[0] + ".displacementShader");
					}
			//MATCH MATS
			setAttr ($newSWShader + ".diffuse") 1;	
			float $diffuseRGBVals[] = `getAttr ($currentSurfaceShader[$n] + ".color")`;
			setAttr ($newSWShader + ".color") $diffuseRGBVals[0] $diffuseRGBVals[1] $diffuseRGBVals[2];
			string $connectedToDiffuse[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".color")`;
			if ($connectedToDiffuse[0] != "")
				{	
				defaultNavigation -ce -source $connectedToDiffuse[0] -destination ($newSWShader + ".color");
				//connectAttr -force ($connectedToDiffuse[0] + ".outColor") ($newSWShader + ".color");//change this to an auto-detection of what's connected to .outColor
				}	
			float $opacityRGBVals[] = `getAttr ($currentSurfaceShader[$n] + ".opacityMap")`;

			setAttr ($newSWShader + ".transparency") (1 - $opacityRGBVals[0]) (1 - $opacityRGBVals[1]) (1 - $opacityRGBVals[2]);//inverse 
			string $connectedToTrans[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".opacityMap")`;
			if ($connectedToTrans[0] != "")
				{	
				defaultNavigation -ce -source $connectedToTrans[0] -destination ($newSWShader + ".transparency");
				}	

			string $bumpConnect[] = `listConnections -d 1 -s 1 ($currentSurfaceShader[$n] + ".bumpMap")`;
			if ($bumpConnect[0] != "")//if something's connected to bump 
				{	
				defaultNavigation -ce -source $bumpConnect[0] -destination ($newSWShader + ".normalCamera");//the easy way to connect a file to a bump slot and have it create bump2d
				}

			float $incandRGBVals[] = `getAttr ($currentSurfaceShader[$n] + ".illumColor")`;
			setAttr ($newSWShader + ".incandescence") $incandRGBVals[0] $incandRGBVals[1] $incandRGBVals[2]; 
			string $connectedToIncand[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".illumColor")`;
			if ($connectedToIncand[0] != "")
				{	
				defaultNavigation -ce -source $connectedToIncand[0] -destination ($newSWShader + ".incandescence");
				}	
	
			if ($MayaSWShader == "blinn")//type is blinn, it has more specular options 
				{
				//setAttr ($newSWShader + ".brdfType") 1;
				float $glossyRGBVal = `getAttr ($currentSurfaceShader[$n] + ".reflectionGlossiness")`;//0 is glossy specular, 1 is rough and wide
				setAttr ($newSWShader + ".eccentricity") (1 - $glossyRGBVal);//inverse
				string $connectedToReflec[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".reflectionGlossiness")`;
				if ($connectedToReflec[0] != "")
					{	
					defaultNavigation -ce -source $connectedToReflec[0] -destination ($newSWShader + ".eccentricity");
					}	
	
				float $specularityScalar = `getAttr ($currentSurfaceShader[$n] + ".reflectionColorAmount")`;
	
				string $connectedToSpec[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".reflectionColorAmount")`;
				if ($connectedToSpec[0] != "")
					{	
					defaultNavigation -ce -source $connectedToSpec[0] -destination ($newSWShader + ".specularRollOff");
					}	
				setAttr ($newSWShader + ".specularRollOff") $specularityScalar;//inverse

				}
			if (($MayaSWShader == "blinn") || ($MayaSWShader == "phong"))//type is blinn, it has more specular options 
				{	
				float $specularRGBVals[] = `getAttr ($currentSurfaceShader[$n] + ".reflectionColor")`;//0 is glossy specular, 1 is rough and wide
				setAttr ($newSWShader + ".specularColor") $specularRGBVals[0] $specularRGBVals[1] $specularRGBVals[2];//set up new shader to match
				string $connectedToRefColor[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".reflectionColor")`;
				if ($connectedToRefColor[0] != "")
					{	
					defaultNavigation -ce -source $connectedToRefColor[0] -destination ($newSWShader + ".specularColor");
					}	
				}
			if ($MayaSWShader == "phong") 
				{
				//setAttr ($newSWShader + ".brdfType") 0;
				float $glossiness = `getAttr ($currentSurfaceShader[$n] + ".reflectionGlossiness")`;//0 is glossy specular, 100 is rough and wide
				setAttr ($newSWShader + ".cosinePower") ($glossiness * 100);
				string $connectedToGloss[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".reflectionGlossiness")`;
				if ($connectedToGloss[0] != "")
					{	
					defaultNavigation -ce -source $connectedToGloss[0] -destination ($newSWShader + ".cosinePower");
					}	
				}
				
			}
			else if (($selectedMatType[1] == "lambert") || ($selectedMatType[1] == "blinn") || ($selectedMatType[1] == "phong"))
				{
				switch($selectedMatType[1]) 
					{
				   case "lambert":
					  $VRayShader = "lambert";
					  break;
				   case "blinn":
					  $VRayShader = "blinn";
					  break;
				   case "phong":
					  $VRayShader = "phong";
					  break;
				   }
	
				string $NewVRayShader = `shadingNode -asShader VRayMtl -name ($currentSurfaceShader[$n] + "_VRay")`; 
				select -d;
				hyperShade -objects $currentSurfaceShader[$n];
				hyperShade -assign $NewVRayShader;
				//get new parent SG for created shader
				string $NewVRayShaderSG[] = `listConnections -s 0 -d 1 -type "shadingEngine" $NewVRayShader`;
				//if displacement wasn't empty, attach it to new mat
				if ($currentSurfaceShaderDisplace[0] != "");
					{
					//connectAttr "displacementShader1.displacement" "phong1SG.displacementShader";
					connectAttr ($currentSurfaceShaderDisplace[0] + ".displacement") ($NewVRayShaderSG[0] + ".displacementShader");
					}
					
				//MATCH MATS HERE
				//get any connections to diffuse, transparency, bump, incandescence, gloss and spec
				float $diffuseRGBVals[] = `getAttr ($currentSurfaceShader[$n] + ".color")`;
				setAttr ($NewVRayShader + ".color") $diffuseRGBVals[0] $diffuseRGBVals[1] $diffuseRGBVals[2];//set up new shader to match
				string $connectedToDiffuse[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".color")`;
				if ($connectedToDiffuse[0] != "")
					{	
					defaultNavigation -ce -source $connectedToDiffuse[0] -destination ($NewVRayShader + ".color");
					}	
	
				float $opacityRGBVals[] = `getAttr ($currentSurfaceShader[$n] + ".transparency")`;
				setAttr ($NewVRayShader + ".opacityMap") (1 - $opacityRGBVals[0]) (1 - $opacityRGBVals[1]) (1 - $opacityRGBVals[2]);//inverse 
				string $connectedToTrans[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".transparency")`;
				if ($connectedToTrans[0] != "")
					{	
					defaultNavigation -ce -source $connectedToTrans[0] -destination ($NewVRayShader + ".opacityMap");
					}	
	
				string $bumpConnect[] = `listConnections -d 1 -s 1 ($currentSurfaceShader[$n] + ".normalCamera")`;
				if ($bumpConnect[0] != "")//if something's connected to bump 
					{	
					string $connectedBumpTex[] = `listConnections -s 1 -d 0 $bumpConnect[0]`;
					connectAttr -force ($connectedBumpTex[0] + ".outColor") ($NewVRayShader + ".bumpMap");
					}
				float $incandRGBVals[] = `getAttr ($currentSurfaceShader[$n] + ".incandescence")`;
				setAttr ($NewVRayShader + ".illumColor") $incandRGBVals[0] $incandRGBVals[1] $incandRGBVals[2]; 
				string $connectedToIncand[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".incandescence")`;
				if ($connectedToIncand[0] != "")
					{	
					defaultNavigation -ce -source $connectedToIncand[0] -destination ($NewVRayShader + ".illumColor");
					}
	
				if ($selectedMatType[1] == "blinn")//type is blinn, it has more specular options 
					{
					setAttr ($NewVRayShader + ".brdfType") 1;
					float $glossyRGBVal = `getAttr ($currentSurfaceShader[$n] + ".eccentricity")`;//0 is glossy specular, 1 is rough and wide
					setAttr ($NewVRayShader + ".reflectionGlossiness") (1 - $glossyRGBVal);//inverse
					string $connectedToRefGlos[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".eccentricity")`;
					if ($connectedToRefGlos[0] != "")
						{	
						defaultNavigation -ce -source $connectedToRefGlos[0] -destination ($NewVRayShader + ".reflectionGlossiness");
						}
		
					float $specularityScalar = `getAttr ($currentSurfaceShader[$n] + ".specularRollOff")`;
					setAttr ($NewVRayShader + ".reflectionColorAmount") $specularityScalar;//inverse
					string $connectedToReflectAmount[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".specularRollOff")`;
					if ($connectedToReflectAmount[0] != "")
						{	
						defaultNavigation -ce -source $connectedToReflectAmount[0] -destination ($NewVRayShader + ".reflectionColorAmount");
						}
					}
				if (($selectedMatType[1] == "blinn") || ($selectedMatType[1] == "phong"))//type is blinn, it has more specular options 
					{	
					float $specularRGBVals[] = `getAttr ($currentSurfaceShader[$n] + ".specularColor")`;//0 is glossy specular, 1 is rough and wide
					setAttr ($NewVRayShader + ".reflectionColor") $specularRGBVals[0] $specularRGBVals[1] $specularRGBVals[2];//set up new shader to match
					string $connectedToSpecColor[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".specularColor")`;
					if ($connectedToSpecColor[0] != "")
						{	
						defaultNavigation -ce -source $connectedToSpecColor[0] -destination ($NewVRayShader + ".reflectionColor");
						}
					}
				if ($selectedMatType[1] == "phong") 
					{
					setAttr ($NewVRayShader + ".brdfType") 0;
					float $cosinePowr = `getAttr ($currentSurfaceShader[$n] + ".cosinePower")`;//0 is glossy specular, 100 is rough and wide
					setAttr ($NewVRayShader + ".reflectionGlossiness") ( $cosinePowr / 100);
					string $connectedToGlossColor[] = `listConnections -s 1 -d 1 ($currentSurfaceShader[$n] + ".cosinePower")`;
					if ($connectedToGlossColor[0] != "")
						{	
						defaultNavigation -ce -source $connectedToGlossColor[0] -destination ($NewVRayShader + ".reflectionGlossiness");
						}
					}
				if ($selectedMatType[1] == "lambert") 
					{
					setAttr ($NewVRayShader + ".brdfType") 2;
					}	
				}
		}
	if ($keepMatsFinished == 0)
			{
			delete $currentSurfaceShader;
			}
	}
}

global proc matIDRenderPreview()
{
string $mySelection[] = `ls -sl`;
global string $storedMaterial[] = {};
for ($n=0 ; $n<size($mySelection) ; $n++)//store original mats
	{
		string $mySelectionShapes[] = `listRelatives -s $mySelection[$n]`;
		string $sGroupTemp[] = `listSets -type 1 -o $mySelectionShapes[0]`;
		$storedMaterial[$n] = `listConnections ($sGroupTemp[0] + ".surfaceShader")`;



	}
//setAttr "crystal_1VRayMtl3.vrayColorId" -type double3 0.786511 0.786511 0.786511 ;


//hardware render preview

//reassign original mats
}

global proc disableTextureFiltering()
{
string $toProcess[] = `ls -type "file"`;
for ($n=0 ; $n<size($toProcess) ; $n++)
	{
	setAttr ($toProcess[$n] + ".filterType") 0;
	}
}

global proc linearizerWithInput(string $inputter)
{
//Remember that this only accepts one input - the for loop is in the parent proc
//at this point, $inputter is VRayMtl1.color
string $connectedToInput[] = `listConnections -d 1 -s 1 -p 1 $inputter`;
//ramp1.outColor or multiplyDivide1.output
string $bufferConnections[];
tokenize $connectedToInput[0] "." $bufferConnections;

string $bufferParentMatName[];
tokenize $inputter "." $bufferParentMatName;
string $parentMat = $bufferParentMatName[0];
if ($bufferConnections[1] != "outAlpha") //do loop for all 3-channel connections, 
	{
	$gammaNode = `shadingNode -asUtility gammaCorrect`;
		connectAttr $connectedToInput[0] ($gammaNode + ".value");
		setAttr ($gammaNode + ".gammaX") .454;
		setAttr ($gammaNode + ".gammaY") .454;
		setAttr ($gammaNode + ".gammaZ") .454;
		connectAttr -force ($gammaNode + ".value") $inputter;
		rename $gammaNode ($parentMat + "_degamma") ;
	}
else if ($bufferConnections[1] == "outAlpha") //do loop for .outAlpha connections, 
	{
	print "do loop for .outAlpha connections\n";
	}
}

global proc editAllTextures()
{
string $mySelection[] = `ls -sl`;
for ($n=0 ; $n<size($mySelection) ; $n++)
	{
	AEfileTextureEditCmd ($mySelection[$n] + ".fileTextureName");
	}
}

global proc copyTexturerer()
{
string $mySelection[] = `ls -sl -exactType "file"`;
for ($n=0 ; $n<size($mySelection) ; $n++)
	{
	string $projectDir = `workspace -q -rd`;
	string $filename = `getAttr ($mySelection[$n] + ".ftn")`;
	string $buffer[];
	$numTokens = `tokenize $filename "/" $buffer`;
	int $filenameMaxNum = `size($buffer)`;
	//test for working link
    int $resulter = `filetest -f $filename`;
    if ($resulter == 1)
        {
		sysFile -copy ($projectDir + "sourceimages/" + $buffer[($filenameMaxNum - 1)] ) $filename;         
        setAttr -type "string" ($mySelection[$n] + ".fileTextureName") ($projectDir + "sourceimages/" + $buffer[($filenameMaxNum - 1)] );
		}
	}
}

global proc selectExternalSourceimages()
{
uniqueNamer;
string $mySelectionImages[] = `ls -type "file"`;
select -d;
for ($n=0 ; $n<size($mySelectionImages) ; $n++)
	{
	string $projectDir = `workspace -q -rd`;
	string $filename = `getAttr ($mySelectionImages[$n] + ".ftn")`;
	string $buffer[];
	$numTokens = `tokenize $filename "/" $buffer`;
	int $filenameMaxNum = `size($buffer)`;
	//for images that have a good path:
	if ($filenameMaxNum > 2)
		{
		string $filesBuiltPath = ($projectDir + ($buffer[($filenameMaxNum - 2)]) + "/" + ($buffer[($filenameMaxNum - 1)]));
	    if ($filesBuiltPath != $filename)//if file's path doesn't match where it would be in project sourceimages, it's external 
			{
			select -add $mySelectionImages[$n];
			}
		}
  }
}

global proc selectFromMats()
{
hyperShade -objects "";
string $selectedFacees[] = `ls -sl`;
select -d;
for ($n=0 ; $n<size($selectedFacees) ; $n++)
	{
	string $buffer[];
	$numTokens = `tokenize $selectedFacees[$n] "." $buffer`;
	select -add $buffer[0];
	}
}

global proc czecherMatTooVRT()
{
string $mySelection[] = `ls -sl`;
$newMat = `shadingNode -asShader lambert -n ChubbyChecker`;
for ($n=0 ; $n<size($mySelection) ; $n++)
{
	select -r $mySelection[$n];
	hyperShade -assign $newMat $mySelection[$n];
}
$checkerText = `shadingNode -asTexture file`;
$checkerTwoDs = `shadingNode -asUtility place2dTexture`;
//get path for download
string $homescriptpathy = `getenv "MAYA_SCRIPT_PATH"`;
string $buffero[];
$numTokens = `tokenize $homescriptpathy ":" $buffero`;
global string $homeScriptDir;
$homeScriptDir = $buffero[2];
global int $fileResulter;
if( `about -mac`)
	{
	$fileResulter = `filetest -f ($homeScriptDir + "/ppp_uvchecker.png")`;
	}
else if( `about -linux64`)
	{
	$fileResulter = `filetest -f ($homeScriptDir + "/ppp_uvchecker.png")`;
	}
else if( `about -win`)
	{
	string $homescriptpathy = `getenv "MAYA_SCRIPT_PATH"`;
	string $buffero[];
	$numTokens = `tokenize $homescriptpathy ";" $buffero`;
	$homeScriptDir = $buffero[2];
	$fileResulter = `filetest -f ($homeScriptDir + "/ppp_uvchecker.png")`;
	}

if ($fileResulter)
	{
	setAttr -type "string" ($checkerText + ".fileTextureName") ($homeScriptDir + "/ppp_uvchecker.png");
	connectAttr ($checkerTwoDs + ".outUV") ($checkerText + ".uv");
	connectAttr -force ($checkerText + ".outColor") ($newMat + ".color");
	setAttr ($checkerTwoDs + ".repeatU") 1;
	setAttr ($checkerTwoDs + ".repeatV") 1;
	}
else if ($fileResulter == 0)
{
	string $resultCheck = `confirmDialog -title "UV Checker mat missing." -message "Download UV checker JPEG?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`;

		if ($resultCheck == "Yes") 
		{
			//set path for download
			if( `about -mac`)
				{
				string $homescriptpathy = `getenv "MAYA_SCRIPT_PATH"`;
				string $buffero[];
				$numTokens = `tokenize $homescriptpathy ":" $buffero`;
				string $homeScriptDir = $buffero[2];
				//system ("cd " + $homeScriptDir + "\; /usr/bin/curl -O http://www.can-con.ca/tumblrpics/ppp_uvchecker.png");
				python( "import maya.mel\nimport urllib\npathy = maya.mel.eval(\"$temp=$homeScriptDir\")\nfullpathy = pathy + '/ppp_uvchecker.png'\nurllib.urlretrieve('http://www.can-con.ca/tumblrpics/ppp_uvchecker.png', fullpathy)" );
				}
			else if( `about -win`)
				{
				string $homescriptpathy = `getenv "MAYA_SCRIPT_PATH"`;
				string $buffero[];
				$numTokens = `tokenize $homescriptpathy ";" $buffero`;
				$homeScriptDir = $buffero[2];
				python( "import maya.mel\nimport urllib\npathy = maya.mel.eval(\"$temp=$homeScriptDir\")\nfullpathy = pathy + '/ppp_uvchecker.png'\nurllib.urlretrieve('http://www.can-con.ca/tumblrpics/ppp_uvchecker.png', fullpathy)" );
				}
			else if( `about -linux64`)
				{
				string $homescriptpathy = `getenv "MAYA_SCRIPT_PATH"`;
				string $buffero[];
				$numTokens = `tokenize $homescriptpathy ":" $buffero`;
				string $homeScriptDir = $buffero[2];
				system ("cd " + $homeScriptDir + "\; curl -O http://www.can-con.ca/tumblrpics/ppp_uvchecker.png");	
				}
			setAttr -type "string" ($checkerText + ".fileTextureName") ($homeScriptDir + "/ppp_uvchecker.png");
			connectAttr ($checkerTwoDs + ".outUV") ($checkerText + ".uv");
			connectAttr -force ($checkerText + ".outColor") ($newMat + ".color");
			setAttr ($checkerTwoDs + ".repeatU") 1;
			setAttr ($checkerTwoDs + ".repeatV") 1;
		}
		else 
		{
		error "You need the colour PNG UV checker mat to use this.";
		}
}
}

global proc selectMissingTextures()
{
string $fileLister[] = `ls -type "file"`; 
string $filePathTexture[];
select -d;
for ($n=0 ; $n<size($fileLister) ; $n++)
    {
    $filePathTexture[$n] = `getAttr ($fileLister[$n] + ".fileTextureName")`;
    //test for working link
    int $resulter = `filetest -f $filePathTexture[$n]`;
    if ($resulter == 0)
        {
          select -add $fileLister[$n];
        }
    }
}

global proc deGammaSwatchUI()
{
if ( `window -exists deGamma` )
  deleteUI -window deGamma;
string $currentSelect[] = `ls -sl`;
string $deGamma = `window -tlb true deGamma`;
columnLayout -adjustableColumn true -columnAttach "both" 8;
columnLayout;
separator -style "none" -w 280 -h 12;
text "Type of material to apply degamma to:";	
columnLayout;
			optionMenuGrp -width 280 deGammaMenu;
			menuItem -label "Selected Texture Nodes";
			//menuItem -label "All Swatches of Selected V-Ray Mat";
			menuItem -label "All Swatches/Textures of selected Vray Mats";
			menuItem -label "All Swatches/Textures of selected Hair3 Mats";
//			menuItem -label "Diffuse Swatch of Selected V-Ray Mats";
			menuItem -label "All Swatches/Textures of FastSSS2 Mats";
setParent ..;
columnLayout;
button -w 280 -h 30 -l "Linearize Selected" -c "deGammaEr;";
separator -style "none" -w 280 -h 12;
showWindow $deGamma;
if (`size $currentSelect` > 0)
	{
	string $typeTester[] = `ls -sl -showType $currentSelect[0]`;
	if ($typeTester[1] == "VRayMtl")
		{
		optionMenuGrp -e -value "All Swatches/Textures of selected Vray Mats" deGammaMenu;
		}
	if ($typeTester[1] == "VRayMtlHair3")
		{
		optionMenuGrp -e -value "All Swatches/Textures of selected Hair3 Mats" deGammaMenu;
		}
	if ($typeTester[1] == "file")
		{
		optionMenuGrp -e -value "Selected Texture Nodes" deGammaMenu;
		}
	if ($typeTester[1] == "VRayFastSSS2")
		{
		optionMenuGrp -e -value "All Swatches/Textures of FastSSS2 Mats" deGammaMenu;
		}
	}
}

global proc deGammaEr()
{
string $currentdeGammaValue = `optionMenuGrp -q -v deGammaMenu`;
string $myMatSelection[] = `ls -sl`;

switch($currentdeGammaValue) 
	{
//  case "Diffuse Swatch of selected V-Ray Mats":
//  	for ($n=0 ; $n<size($myMatSelection) ; $n++)
//		{ 
//		float $storedRGB[3] = `getAttr ($myMatSelection[$n] + ".color")`;
//		string $gammaNode = `shadingNode -asUtility gammaCorrect`;
//		setAttr ($gammaNode + ".gammaX") .454;
//		setAttr ($gammaNode + ".gammaY") .454;
//		setAttr ($gammaNode + ".gammaZ") .454;
//		setAttr ($gammaNode + ".value") -type double3 $storedRGB[0] $storedRGB[1] $storedRGB[2];
//		connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".color");
//		rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
//		}
//   break;
   
   	case "Selected Texture Nodes":
      LWFMeTexture;
      break;

   	case "All Swatches/Textures of selected Vray Mats":
	for ($n=0 ; $n<size($myMatSelection) ; $n++)
		{ 
		//diffuse
		string $connectedDiffuse; 
		string $tmpConnect[] = `listConnections ($myMatSelection[$n] + ".color")`;
		string $connectedDiffuse = $tmpConnect[0]; 
		string $typeTestDiffuse[] = `ls -showType $connectedDiffuse`;
		
		if ( $typeTestDiffuse[1] == "file" )//texture nodes
			{
				vray addAttributesFromGroup $connectedDiffuse vray_file_gamma 1;
				setAttr ($connectedDiffuse + ".vrayFileGammaEnable") 1;
			}
		else if ( $typeTestDiffuse[1] == "gammaCorrect" )
			{
				print "nothing for already gamma-corrected diffuse node\n";
			}
		else if ( $connectedDiffuse == "" )//just swatch with no connection
			{
			float $storedRGBb[3] = `getAttr ($myMatSelection[$n] + ".color")`;
			string $gammaNode = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNode + ".gammaX") .454;
			setAttr ($gammaNode + ".gammaY") .454;
			setAttr ($gammaNode + ".gammaZ") .454;
			setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
			connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".color");
			rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
			}
		else if ( !($typeTestDiffuse[$n] == "") )//brute force degamma if not empty and none of the above
			{
			//send linearizer selected Vray Material and specify channel (here .color)
			print $myMatSelection[$n];
			linearizerWithInput($myMatSelection[$n] + ".color");
			}
		////self illum - illumColor
		string $connectedSelfIllum; 
		string $tmpConnect[] = `listConnections ($myMatSelection[$n] + ".illumColor")`;
		string $connectedSelfIllum = $tmpConnect[0]; 
		string $typeTestSelfIllum[] = `ls -showType $connectedSelfIllum`;
		
		if ( $typeTestSelfIllum[1] == "file" )//texture nodes
			{
				vray addAttributesFromGroup $connectedSelfIllum vray_file_gamma 1;
				setAttr ($connectedSelfIllum + ".vrayFileGammaEnable") 1;
			}
		else if ( $typeTestSelfIllum[1] == "gammaCorrect" )
			{
				print "nothing for already gamma-corrected SelfIllum node\n";
			}
		else if ( $connectedSelfIllum == "" )//just swatch with no connection
			{
			float $storedRGBb[3] = `getAttr ($myMatSelection[$n] + ".illumColor")`;
			string $gammaNode = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNode + ".gammaX") .454;
			setAttr ($gammaNode + ".gammaY") .454;
			setAttr ($gammaNode + ".gammaZ") .454;
			setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
			connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".illumColor");
			rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
			}
		else if ( !($typeTestSelfIllum[$n] == "") )//brute force degamma if not empty and none of the above
			{
			print $myMatSelection[$n];
			linearizerWithInput($myMatSelection[$n] + ".illumColor");
			}
		//		//reflect - reflectionColor
		string $connectedReflection; 
		string $tmpConnect[] = `listConnections ($myMatSelection[$n] + ".reflectionColor")`;
		string $connectedReflection = $tmpConnect[0]; 
		string $typeTestReflection[] = `ls -showType $connectedReflection`;
		
		if ( $typeTestReflection[1] == "file" )//texture nodes
			{
				vray addAttributesFromGroup $connectedReflection vray_file_gamma 1;
				setAttr ($connectedReflection + ".vrayFileGammaEnable") 1;
			}
		else if ( $typeTestReflection[1] == "gammaCorrect" )
			{
				print "nothing for already gamma-corrected Reflection node\n";
			}
		else if ( $connectedReflection == "" )//just swatch with no connection
			{
			float $storedRGBb[3] = `getAttr ($myMatSelection[$n] + ".reflectionColor")`;
			string $gammaNode = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNode + ".gammaX") .454;
			setAttr ($gammaNode + ".gammaY") .454;
			setAttr ($gammaNode + ".gammaZ") .454;
			setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
			connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".reflectionColor");
			rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
			}
		else if ( !($typeTestReflection[$n] == "") )//brute force degamma if not empty and none of the above
			{
			print $myMatSelection[$n];
			linearizerWithInput($myMatSelection[$n] + ".reflectionColor");
			}

//		//refract - refractionColor
		string $connectedRefraction; 
		string $tmpConnect[] = `listConnections ($myMatSelection[$n] + ".refractionColor")`;
		string $connectedRefraction = $tmpConnect[0]; 
		string $typeTestRefraction[] = `ls -showType $connectedRefraction`;
		
		if ( $typeTestRefraction[1] == "file" )//texture nodes
			{
				vray addAttributesFromGroup $connectedRefraction vray_file_gamma 1;
				setAttr ($connectedRefraction + ".vrayFileGammaEnable") 1;
			}
		else if ( $typeTestRefraction[1] == "gammaCorrect" )
			{
				print "nothing for already gamma-corrected Refraction node\n";
			}
		else if ( $connectedRefraction == "" )//just swatch with no connection
			{
			float $storedRGBb[3] = `getAttr ($myMatSelection[$n] + ".refractionColor")`;
			string $gammaNode = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNode + ".gammaX") .454;
			setAttr ($gammaNode + ".gammaY") .454;
			setAttr ($gammaNode + ".gammaZ") .454;
			setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
			connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".refractionColor");
			rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
			}
		else if ( !($typeTestRefraction[$n] == "") )//brute force degamma if not empty and none of the above
			{
			print $myMatSelection[$n];
			linearizerWithInput($myMatSelection[$n] + ".refractionColor");
			}
//		//fog - fogColor
		string $connectedFog; 
		string $tmpConnect[] = `listConnections ($myMatSelection[$n] + ".fogColor")`;
		string $connectedFog = $tmpConnect[0]; 
		string $typeTestFog[] = `ls -showType $connectedFog`;
		
		if ( $typeTestFog[1] == "file" )//texture nodes
			{
				vray addAttributesFromGroup $connectedFog vray_file_gamma 1;
				setAttr ($connectedFog + ".vrayFileGammaEnable") 1;
			}
		else if ( $typeTestFog[1] == "gammaCorrect" )
			{
				print "nothing for already gamma-corrected Fog node\n";
			}
		else if ( $connectedFog == "" )//just swatch with no connection
			{
			float $storedRGBb[3] = `getAttr ($myMatSelection[$n] + ".fogColor")`;
			string $gammaNode = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNode + ".gammaX") .454;
			setAttr ($gammaNode + ".gammaY") .454;
			setAttr ($gammaNode + ".gammaZ") .454;
			setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
			connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".fogColor");
			rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
			}
		else if ( !($typeTestFog[$n] == "") )//brute force degamma if not empty and none of the above
			{
			print $myMatSelection[$n];
			linearizerWithInput($myMatSelection[$n] + ".fogColor");
			}

//		//sss - translucencyColor
		string $connectedTranslu; 
		string $tmpConnect[] = `listConnections ($myMatSelection[$n] + ".translucencyColor")`;
		string $connectedTranslu = $tmpConnect[0]; 
		string $typeTestTranslu[] = `ls -showType $connectedTranslu`;
		
		if ( $typeTestTranslu[1] == "file" )//texture nodes
			{
				vray addAttributesFromGroup $connectedTranslu vray_file_gamma 1;
				setAttr ($connectedTranslu + ".vrayFileGammaEnable") 1;
			}
		else if ( $typeTestTranslu[1] == "gammaCorrect" )
			{
				print "nothing for already gamma-corrected Translu node\n";
			}
		else if ( $connectedTranslu == "" )//just swatch with no connection
			{
			float $storedRGBb[3] = `getAttr ($myMatSelection[$n] + ".translucencyColor")`;
			string $gammaNode = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNode + ".gammaX") .454;
			setAttr ($gammaNode + ".gammaY") .454;
			setAttr ($gammaNode + ".gammaZ") .454;
			setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
			connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".translucencyColor");
			rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
			}
		else if ( !($typeTestTranslu[$n] == "") )//brute force degamma if not empty and none of the above
			{
			print $myMatSelection[$n];
			linearizerWithInput($myMatSelection[$n] + ".translucencyColor");
			}	
		}
      break;
   	
   	case "All Swatches/Textures of selected Hair3 Mats":
      for ($n=0 ; $n<size($myMatSelection) ; $n++)
		{ 
		//Overall colour
		string $connectedOverall; 
		string $tmpConnect[] = `listConnections ($myMatSelection[$n] + ".overallColor")`;
		string $connectedOverall = $tmpConnect[0]; 
		string $typeTestOverall[] = `ls -showType $connectedOverall`;
		
		if ( $typeTestOverall[1] == "file" )//texture nodes
			{
				vray addAttributesFromGroup $connectedOverall vray_file_gamma 1;
				setAttr ($connectedOverall + ".vrayFileGammaEnable") 1;
			}
		else if ( $typeTestOverall[1] == "gammaCorrect" )
			{
				print "nothing for already gamma-corrected diffuse node\n";
			}
		else if ( $connectedOverall == "" )//just swatch with no connection
			{
			float $storedRGBb[3] = `getAttr ($myMatSelection[$n] + ".overallColor")`;
			string $gammaNode = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNode + ".gammaX") .454;
			setAttr ($gammaNode + ".gammaY") .454;
			setAttr ($gammaNode + ".gammaZ") .454;
			setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
			connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".overallColor");
			rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
			}
		else if ( !($typeTestOverall[$n] == "") )//brute force degamma if not empty and none of the above
			{
			//send linearizer selected Vray Material and specify channel (here .color)
			print $myMatSelection[$n];
			linearizerWithInput($myMatSelection[$n] + ".overallColor");
			}
		////trasparency
		string $connectedTransparency; 
		string $tmpConnect[] = `listConnections ($myMatSelection[$n] + ".transparency")`;
		string $connectedTransparency = $tmpConnect[0]; 
		string $typeTestTransparency[] = `ls -showType $connectedTransparency`;
		
		if ( $typeTestTransparency[1] == "file" )//texture nodes
			{
				vray addAttributesFromGroup $connectedTransparency vray_file_gamma 1;
				setAttr ($connectedTransparency + ".vrayFileGammaEnable") 1;
			}
		else if ( $typeTestTransparency[1] == "gammaCorrect" )
			{
				print "nothing for already gamma-corrected diffuse node\n";
			}
		else if ( $connectedTransparency == "" )//just swatch with no connection
			{
			float $storedRGBb[3] = `getAttr ($myMatSelection[$n] + ".transparency")`;
			string $gammaNode = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNode + ".gammaX") .454;
			setAttr ($gammaNode + ".gammaY") .454;
			setAttr ($gammaNode + ".gammaZ") .454;
			setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
			connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".transparency");
			rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
			}
		else if ( !($typeTestTransparency[$n] == "") )//brute force degamma if not empty and none of the above
			{
			//send linearizer selected Vray Material and specify channel (here .color)
			print $myMatSelection[$n];
			linearizerWithInput($myMatSelection[$n] + ".transparency");
			}
		///diffuseColor
		string $connectedDiffuseColor; 
		string $tmpConnect[] = `listConnections ($myMatSelection[$n] + ".diffuseColor")`;
		string $connectedDiffuseColor = $tmpConnect[0]; 
		string $typeTestDiffuseColor[] = `ls -showType $connectedDiffuseColor`;
		
		if ( $typeTestDiffuseColor[1] == "file" )//texture nodes
			{
				vray addAttributesFromGroup $connectedDiffuseColor vray_file_gamma 1;
				setAttr ($connectedDiffuseColor + ".vrayFileGammaEnable") 1;
			}
		else if ( $typeTestDiffuseColor[1] == "gammaCorrect" )
			{
				print "nothing for already gamma-corrected diffuse node\n";
			}
		else if ( $connectedDiffuseColor == "" )//just swatch with no connection
			{
			float $storedRGBb[3] = `getAttr ($myMatSelection[$n] + ".diffuseColor")`;
			string $gammaNode = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNode + ".gammaX") .454;
			setAttr ($gammaNode + ".gammaY") .454;
			setAttr ($gammaNode + ".gammaZ") .454;
			setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
			connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".diffuseColor");
			rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
			}
		else if ( !($typeTestDiffuseColor[$n] == "") )//brute force degamma if not empty and none of the above
			{
			//send linearizer selected Vray Material and specify channel (here .color)
			print $myMatSelection[$n];
			linearizerWithInput($myMatSelection[$n] + ".diffuseColor");
			}
		///primarySpecular
		string $connectedPrimarySpecular; 
		string $tmpConnect[] = `listConnections ($myMatSelection[$n] + ".primarySpecular")`;
		string $connectedPrimarySpecular = $tmpConnect[0]; 
		string $typeTestPrimarySpecular[] = `ls -showType $connectedPrimarySpecular`;
		
		if ( $typeTestPrimarySpecular[1] == "file" )//texture nodes
			{
				vray addAttributesFromGroup $connectedPrimarySpecular vray_file_gamma 1;
				setAttr ($connectedPrimarySpecular + ".vrayFileGammaEnable") 1;
			}
		else if ( $typeTestPrimarySpecular[1] == "gammaCorrect" )
			{
				print "nothing for already gamma-corrected diffuse node\n";
			}
		else if ( $connectedPrimarySpecular == "" )//just swatch with no connection
			{
			float $storedRGBb[3] = `getAttr ($myMatSelection[$n] + ".primarySpecular")`;
			string $gammaNode = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNode + ".gammaX") .454;
			setAttr ($gammaNode + ".gammaY") .454;
			setAttr ($gammaNode + ".gammaZ") .454;
			setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
			connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".primarySpecular");
			rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
			}
		else if ( !($typeTestPrimarySpecular[$n] == "") )//brute force degamma if not empty and none of the above
			{
			//send linearizer selected Vray Material and specify channel (here .color)
			print $myMatSelection[$n];
			linearizerWithInput($myMatSelection[$n] + ".primarySpecular");
			}
		///secondarySpecular
		string $connectedSecondarySpecular; 
		string $tmpConnect[] = `listConnections ($myMatSelection[$n] + ".secondarySpecular")`;
		string $connectedSecondarySpecular = $tmpConnect[0]; 
		string $typeTestSecondarySpecular[] = `ls -showType $connectedSecondarySpecular`;
		
		if ( $typeTestSecondarySpecular[1] == "file" )//texture nodes
			{
				vray addAttributesFromGroup $connectedSecondarySpecular vray_file_gamma 1;
				setAttr ($connectedSecondarySpecular + ".vrayFileGammaEnable") 1;
			}
		else if ( $typeTestSecondarySpecular[1] == "gammaCorrect" )
			{
				print "nothing for already gamma-corrected diffuse node\n";
			}
		else if ( $connectedSecondarySpecular == "" )//just swatch with no connection
			{
			float $storedRGBb[3] = `getAttr ($myMatSelection[$n] + ".secondarySpecular")`;
			string $gammaNode = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNode + ".gammaX") .454;
			setAttr ($gammaNode + ".gammaY") .454;
			setAttr ($gammaNode + ".gammaZ") .454;
			setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
			connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".secondarySpecular");
			rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
			}
		else if ( !($typeTestSecondarySpecular[$n] == "") )//brute force degamma if not empty and none of the above
			{
			//send linearizer selected Vray Material and specify channel (here .color)
			print $myMatSelection[$n];
			linearizerWithInput($myMatSelection[$n] + ".secondarySpecular");
			}
		///transmission
		string $connectedTransmission; 
		string $tmpConnect[] = `listConnections ($myMatSelection[$n] + ".transmission")`;
		string $connectedTransmission = $tmpConnect[0]; 
		string $typeTestTransmission[] = `ls -showType $connectedTransmission`;
		
		if ( $typeTestTransmission[1] == "file" )//texture nodes
			{
				vray addAttributesFromGroup $connectedTransmission vray_file_gamma 1;
				setAttr ($connectedTransmission + ".vrayFileGammaEnable") 1;
			}
		else if ( $typeTestTransmission[1] == "gammaCorrect" )
			{
				print "nothing for already gamma-corrected diffuse node\n";
			}
		else if ( $connectedTransmission == "" )//just swatch with no connection
			{
			float $storedRGBb[3] = `getAttr ($myMatSelection[$n] + ".transmission")`;
			string $gammaNode = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNode + ".gammaX") .454;
			setAttr ($gammaNode + ".gammaY") .454;
			setAttr ($gammaNode + ".gammaZ") .454;
			setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
			connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".transmission");
			rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
			}
		else if ( !($typeTestTransmission[$n] == "") )//brute force degamma if not empty and none of the above
			{
			//send linearizer selected Vray Material and specify channel (here .color)
			print $myMatSelection[$n];
			linearizerWithInput($myMatSelection[$n] + ".transmission");
			}	
		}
	  break;	
		
   	case "All Swatches/Textures of FastSSS2 Mats":
      for ($n=0 ; $n<size($myMatSelection) ; $n++)
		{ 
		//diffuse
		string $connectedoverallTex; 
		string $tmpConnect[] = `listConnections -type "file" ($myMatSelection[$n] + ".overallTex")`;
		string $connectedoverallTex = $tmpConnect[0]; 
		if ( $connectedoverallTex != "" )
			{
			vray addAttributesFromGroup $connectedoverallTex vray_file_gamma 1;
			setAttr ($connectedoverallTex + ".vrayFileGammaEnable") 1;
			}
		else if ( $connectedoverallTex == "" )
			{
			float $storedRGBb[3] = `getAttr ($myMatSelection[$n] + ".overallTex")`;
			string $gammaNode = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNode + ".gammaX") .454;
			setAttr ($gammaNode + ".gammaY") .454;
			setAttr ($gammaNode + ".gammaZ") .454;
			setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
			connectAttr -force ($gammaNode + ".outValue") ($myMatSelection[$n] + ".overallTex");
			rename $gammaNode ($myMatSelection[$n] + "_degamma") ;
			}
		//self illum - illumColor
		string $connecteddiffuseTex; 
		string $tmpConnecterdiffuseTex[] = `listConnections -type "file" ($myMatSelection[$n] + ".diffuseTex")`;
		string $connecteddiffuseTex = $tmpConnecterdiffuseTex[0]; 
		if ( $connecteddiffuseTex != "" )
			{
			vray addAttributesFromGroup $connecteddiffuseTex vray_file_gamma 1;
			setAttr ($connecteddiffuseTex + ".vrayFileGammaEnable") 1;
			}
		else if ( $connecteddiffuseTex == "" )
			{
			float $storedRGBX[3] = `getAttr ($myMatSelection[$n] + ".diffuseTex")`;
			string $gammaNodeX = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNodeX + ".gammaX") .454;
			setAttr ($gammaNodeX + ".gammaY") .454;
			setAttr ($gammaNodeX + ".gammaZ") .454;
			setAttr ($gammaNodeX + ".value") -type double3 $storedRGBX[0] $storedRGBX[1] $storedRGBX[2];
			connectAttr -force ($gammaNodeX + ".outValue") ($myMatSelection[$n] + ".diffuseTex");
			rename $gammaNodeX ($myMatSelection[$n] + "_degamma") ;
			}
		//reflect - reflectionColor
		string $connectedreflectC; 
		string $tmpConnecterreflec[] = `listConnections -type "file" ($myMatSelection[$n] + ".subsurfaceColor")`;
		string $connectedreflectC = $tmpConnecterreflec[0]; 
		if ( $connectedreflectC != "" )
			{
			vray addAttributesFromGroup $connectedreflectC vray_file_gamma 1;
			setAttr ($connectedreflectC + ".vrayFileGammaEnable") 1;
			}
		else if ( $connectedreflectC == "" )
			{
			float $storedRGBY[3] = `getAttr ($myMatSelection[$n] + ".subsurfaceColor")`;
			string $gammaNodeY = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNodeY + ".gammaX") .454;
			setAttr ($gammaNodeY + ".gammaY") .454;
			setAttr ($gammaNodeY + ".gammaZ") .454;
			setAttr ($gammaNodeY + ".value") -type double3 $storedRGBY[0] $storedRGBY[1] $storedRGBY[2];
			connectAttr -force ($gammaNodeY + ".outValue") ($myMatSelection[$n] + ".subsurfaceColor");
			rename $gammaNodeY ($myMatSelection[$n] + "_degamma") ;
			}
		//refract - refractionColor
		string $connectedScatter; 
		string $tmpConnecterScat[] = `listConnections -type "file" ($myMatSelection[$n] + ".scatterRadiusColor")`;
		string $connectedScatter = $tmpConnecterScat[0]; 
		if ( $connectedScatter != "" )
			{
			vray addAttributesFromGroup $connectedScatter vray_file_gamma 1;
			setAttr ($connectedScatter + ".vrayFileGammaEnable") 1;
			}
		else if ( $connectedScatter == "" )
			{
			float $storedRGBZ[3] = `getAttr ($myMatSelection[$n] + ".scatterRadiusColor")`;
			string $gammaNodeZ = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNodeZ + ".gammaX") .454;
			setAttr ($gammaNodeZ + ".gammaY") .454;
			setAttr ($gammaNodeZ + ".gammaZ") .454;
			setAttr ($gammaNodeZ + ".value") -type double3 $storedRGBZ[0] $storedRGBZ[1] $storedRGBZ[2];
			connectAttr -force ($gammaNodeZ + ".outValue") ($myMatSelection[$n] + ".scatterRadiusColor");
			rename $gammaNodeZ ($myMatSelection[$n] + "_degamma") ;
			}
		//refract - refractionColor
		string $connectedReefer; 
		string $tmpConnecterReefer[] = `listConnections -type "file" ($myMatSelection[$n] + ".reflection")`;
		string $connectedReefer = $tmpConnecterReefer[0]; 
		if ( $connectedReefer != "" )
			{
			vray addAttributesFromGroup $connectedReefer vray_file_gamma 1;
			setAttr ($connectedReefer + ".vrayFileGammaEnable") 1;
			}
		else if ( $connectedReefer == "" )
			{
			float $storedRGBZ[3] = `getAttr ($myMatSelection[$n] + ".reflection")`;
			string $gammaNodeZ = `shadingNode -asUtility gammaCorrect`;
			setAttr ($gammaNodeZ + ".gammaX") .454;
			setAttr ($gammaNodeZ + ".gammaY") .454;
			setAttr ($gammaNodeZ + ".gammaZ") .454;
			setAttr ($gammaNodeZ + ".value") -type double3 $storedRGBZ[0] $storedRGBZ[1] $storedRGBZ[2];
			connectAttr -force ($gammaNodeZ + ".outValue") ($myMatSelection[$n] + ".reflection");
			rename $gammaNodeZ ($myMatSelection[$n] + "_degamma") ;
			}
		}
      break;

   }
}

global proc storedTextureReload()
{
	global string $myStoreTexture[];
	string $myCurrentSelection[] = `ls -sl`;
	
	if (size($myCurrentSelection) > 0)
	{
		string $tmpStore[] = `ls -sl -type "file"`;
		if (!($tmpStore[0] == ""))
		{
			$myStoreTexture[0] =  $tmpStore[0];
			catchQuiet(`AEfileTextureReloadCmd ($myStoreTexture[0] + ".fileTextureName")`);
		}
		else 
			{
			AEfileTextureReloadCmd ($myStoreTexture[0] + ".fileTextureName");   
			}
	}
	else 
	{
	AEfileTextureReloadCmd ($myStoreTexture[0] + ".fileTextureName");   
	}
}

global proc UVTransferMeVR()
{
string $mySelection[] = `ls -sl`;
for ($n=1 ; $n<size($mySelection) ; $n++)
	{
	if ( `size $mySelection` > 2 )
		{
		select -r $mySelection[0];
		select -add $mySelection[$n];
		polyTransfer -uv 1 -ao $mySelection[0] $mySelection[$n];
		}
	else if ( `size $mySelection` < 3 )
		{
		polyTransfer -uv 1 -ao $mySelection[0] $mySelection[1];
		}
	}
}

global proc materialWorkerLayerUI()
{
if ( `window -exists materialWorker` )
  deleteUI -window materialWorker;
string $materialWorker = `window -tlb true materialWorker`;
columnLayout -adjustableColumn true -columnAttach "both" 10;
separator -style "none" -w 180 -h 12;
text "Test object(s) for material:";	
separator -style "none" -w 180 -h 4;
rowColumnLayout -numberOfColumns 2
	-columnWidth 1 90
	-columnWidth 2 90;
checkBox -label "Sphere" -v true materialWorkerCheckbox1;
checkBox -label "Cube" -v false materialWorkerCheckbox2;
setParent ..;
rowColumnLayout -numberOfColumns 2
	-columnWidth 1 90
	-columnWidth 2 90;
checkBox -label "Cylinder" -v false materialWorkerCheckbox3;
checkBox -label "Plane" -v false materialWorkerCheckbox4;
//checkBox -label "Selected mesh" -v false  materialWorkerCheckbox5;

separator -style "none" -h 12;
setParent ..;
button -w 180 -l "1: Material Worker Layer" -ann "Select a V-Ray Material and preview it on your object by pressing this."-c "materialWorkerLayer;";
button -w 180 -l "2: IPR Render (V-Ray RT)" -ann "." -c "IPRMatPreview;";
button -w 180-l "3: Clean Up Material Elements" -ann "Run this when you're done tweaking materials. Otherwise you will have a render layer with these temp objects left over." -c "cameraView -e -camera $cammy -sc $homeNameCammy; delete $domelightVRay; if (`objExists $surfaceShaderTempV`) {delete $surfaceShaderTempV;}; if (`objExists $dummyPlaneYo`) {delete $dummyPlaneYo;}; if (`objExists $dummySphereYo`) {delete $dummySphereYo;}; if (`objExists $dummyCubeYo`) {delete $dummyCubeYo;}; if (`objExists $copyMesh[0]`) {delete $copyMesh[0];}; if (`objExists $dummyCylinderYo`) {delete $dummyCylinderYo;}; delete $keylightVRay; delete $keylightTooVRay; editRenderLayerGlobals -currentRenderLayer $currentRenderLayer; delete \"*_materialworker\"";

separator -style "none" -w 180 -h 3;

button -w 180 -l "Render Utility Preview" -ann "Previews a selected utility node once Material Worker Layer is started (works with many but not all procedural textures and utilities.)" -c "sSurfaceTesterV;";
button -w 180 -l "Node Editor" -c "NodeEditorWindow; ";

separator -style "none" -w 180 -h 12;

showWindow $materialWorker;
}

global proc sSurfaceTesterV()
{
string $typeTest[] = `ls -sl -showType`;
string $myUtilitySelection[] = `ls -sl`;
global string $surfaceShaderTempV;
global string $dummySphereYo;
global string $dummyCylinderYo;
global string $dummyCubeYo;
global string $dummyPlaneYo;

string $surfaceShaderTempV;
if (!`objExists $surfaceShaderTempV`)
	{
	$surfaceShaderTempV = `shadingNode -asShader surfaceShader`;
	}
if ($typeTest[1] == "multiplyDivide")
	{
	connectAttr -force ($myUtilitySelection[0] + ".output") ($surfaceShaderTempV + ".outColor");
	if(`objExists $dummySphereYo`) 
		{
      	select -r $dummySphereYo;
		hyperShade -assign $surfaceShaderTempV $dummySphereYo;
		}
	if(`objExists $dummyCubeYo`) 
		{
      	select -r $dummyCubeYo;
		hyperShade -assign $surfaceShaderTempV $dummyCubeYo;
		}
	if(`objExists $dummyPlaneYo`) 
		{
      	select -r $dummyPlaneYo;
		hyperShade -assign $surfaceShaderTempV $dummyPlaneYo;
		}
	if(`objExists $dummyCylinderYo`) 
		{
      	select -r $dummyCylinderYo;
		hyperShade -assign $surfaceShaderTempV $dummyCylinderYo;
		}
	}	
else if ($typeTest[1] == "gammaCorrect")
	{
	connectAttr -force ($myUtilitySelection[0] + ".outValue") ($surfaceShaderTempV + ".outColor");
	if(`objExists $dummySphereYo`) 
		{
      	select -r $dummySphereYo;
		hyperShade -assign $surfaceShaderTempV $dummySphereYo;
		}
	if(`objExists $dummyCubeYo`) 
		{
      	select -r $dummyCubeYo;
		hyperShade -assign $surfaceShaderTempV $dummyCubeYo;
		}
	if(`objExists $dummyPlaneYo`) 
		{
      	select -r $dummyPlaneYo;
		hyperShade -assign $surfaceShaderTempV $dummyPlaneYo;
		}
	if(`objExists $dummyCylinderYo`) 
		{
      	select -r $dummyCylinderYo;
		hyperShade -assign $surfaceShaderTempV $dummyCylinderYo;
		}
	}	
else if ($typeTest[1] == "blendColors")
	{
	connectAttr -force ($myUtilitySelection[0] + ".output") ($surfaceShaderTempV + ".outColor");
		if(`objExists $dummySphereYo`) 
		{
      	select -r $dummySphereYo;
		hyperShade -assign $surfaceShaderTempV $dummySphereYo;
		}
	if(`objExists $dummyCubeYo`) 
		{
      	select -r $dummyCubeYo;
		hyperShade -assign $surfaceShaderTempV $dummyCubeYo;
		}
	if(`objExists $dummyPlaneYo`) 
		{
      	select -r $dummyPlaneYo;
		hyperShade -assign $surfaceShaderTempV $dummyPlaneYo;
		}
	if(`objExists $dummyCylinderYo`) 
		{
      	select -r $dummyCylinderYo;
		hyperShade -assign $surfaceShaderTempV $dummyCylinderYo;
		}
	}	
else if ($typeTest[1] == "contrast")
	{
	connectAttr -force ($myUtilitySelection[0] + ".outValue") ($surfaceShaderTempV + ".outColor");
		if(`objExists $dummySphereYo`) 
		{
      	select -r $dummySphereYo;
		hyperShade -assign $surfaceShaderTempV $dummySphereYo;
		}
	if(`objExists $dummyCubeYo`) 
		{
      	select -r $dummyCubeYo;
		hyperShade -assign $surfaceShaderTempV $dummyCubeYo;
		}
	if(`objExists $dummyPlaneYo`) 
		{
      	select -r $dummyPlaneYo;
		hyperShade -assign $surfaceShaderTempV $dummyPlaneYo;
		}
	if(`objExists $dummyCylinderYo`) 
		{
      	select -r $dummyCylinderYo;
		hyperShade -assign $surfaceShaderTempV $dummyCylinderYo;
		}
	}	
else if ($typeTest[1] == "plusMinusAverage")
	{
	connectAttr -force ($myUtilitySelection[0] + ".output3D") ($surfaceShaderTempV + ".outColor");
		if(`objExists $dummySphereYo`) 
		{
      	select -r $dummySphereYo;
		hyperShade -assign $surfaceShaderTempV $dummySphereYo;
		}
	if(`objExists $dummyCubeYo`) 
		{
      	select -r $dummyCubeYo;
		hyperShade -assign $surfaceShaderTempV $dummyCubeYo;
		}
	if(`objExists $dummyPlaneYo`) 
		{
      	select -r $dummyPlaneYo;
		hyperShade -assign $surfaceShaderTempV $dummyPlaneYo;
		}
	if(`objExists $dummyCylinderYo`) 
		{
      	select -r $dummyCylinderYo;
		hyperShade -assign $surfaceShaderTempV $dummyCylinderYo;
		}
	}	
//try and connect the outColor for selected random node (longshot)
else {
	connectAttr -force ($myUtilitySelection[0] + ".outColor") ($surfaceShaderTempV + ".outColor");
		if(`objExists $dummySphereYo`) 
		{
      	select -r $dummySphereYo;
		hyperShade -assign $surfaceShaderTempV $dummySphereYo;
		}
	if(`objExists $dummyCubeYo`) 
		{
      	select -r $dummyCubeYo;
		hyperShade -assign $surfaceShaderTempV $dummyCubeYo;
		}
	if(`objExists $dummyPlaneYo`) 
		{
      	select -r $dummyPlaneYo;
		hyperShade -assign $surfaceShaderTempV $dummyPlaneYo;
		}
	if(`objExists $dummyCylinderYo`) 
		{
      	select -r $dummyCylinderYo;
		hyperShade -assign $surfaceShaderTempV $dummyCylinderYo;
		}
	}	
select -d;
}


global proc IPRMatPreview()
{
int $dontSaver = `getAttr "vraySettings.dontSaveImage"`;
if ($dontSaver == 0)
	{
	setAttr "vraySettings.dontSaveImage" 1;
	}
RedoPreviousIPRRender;
if ($dontSaver == 0)
	{
	setAttr "vraySettings.dontSaveImage" 0;
	}
}

global proc materialWorkerLayer()
{
string $matT[] = `ls -sl -showType`;
string $selection[] = `ls -sl -dag -lf`; // remember all Shapenodes in selection 
string $typerTest[] = `ls -showType $selection[0]`;
string $materialSelection[] = `ls -sl`;
string $typerTestToo[] = `ls -showType $materialSelection[0]`;
//////int $selectedMeshState = `checkBox -q -v materialWorkerCheckbox5`;
global string $currentRenderLayer; 
int $sphereState = `checkBox -q -v materialWorkerCheckbox1`;
int $cubeState = `checkBox -q -v materialWorkerCheckbox2`;
int $cylinderState = `checkBox -q -v materialWorkerCheckbox3`;
int $planeState = `checkBox -q -v materialWorkerCheckbox4`;
//store the camera position and rotation
global string $cammy;
$cammy = `getCurrentCamera`;
global string $homeNameCammy;
$homeNameCammy = `cameraView -camera $cammy`;

global string $dummySphereYo;
global string $dummyCubeYo;
global string $dummyCylinderYo;
global string $dummyPlaneYo;
//////global string $copyMesh[];

//////if(!($matT[1] == "VRayBlendMtl") || !($matT[1] == "VRayMtl") || !($matT[1] == "VRayFastSSS2") || !($matT[1] == "VRayBumpMtl") || !($matT[1] == "VRayLightMtl") || !($matT[1] == "VRayFlakesMtl") || !($matT[1] == "VRayCarPaintMtl") && ($selectedMeshState == 1))
//////	{
//////	$currentRenderLayer = `editRenderLayerGlobals -q -crl`;
//////	global string $tempRL;
//////	$tempRL = `createRenderLayer -mc -name "mesh_materialworker" -number 1 -empty`;
//////	
//////	//string $resultX[] = `duplicate -rc $selection`;
//////	string $resultX[] = `instance $selection`;
//////	select -r $resultX[0];
//////	CenterPivt;
//////	move -rpr 0 0 0 ;
//////	$copyMesh = $resultX;
//////	print $copyMesh;
//////
//////	$currentCam = `getCurrentCamera`;
//////	lookThru $currentCam; 
//////	
//////	select -r $copyMesh;
//////	viewFit $currentCam;
//////	select -d;
//////	global string $keylightVRay;
//////	global string $keylightTooVRay;
//////
//////	$keylightVRay = `shadingNode -asLight VRayLightRectShape`;
//////	setAttr ($keylightVRay + ".uSize") 90;
//////	setAttr ($keylightVRay + ".vSize") 90;
//////	move -r 67.263518 75.969143 -79.780579 ;
//////	rotate -r -os -61.12128 52.322899 -25.536819 ;
//////	rotate -r -os -36.251101 38.915846 -6.591787 ;
//////	rotate -r -os -10.578263 11.798781 1.01574 ;
//////	rotate -r -os 12.168729 -12.133367 -5.3062 ;
//////	move -r -os -wd 0 0 149.264805 ;
//////	move -r 85 101 -74 ;
//////	setAttr ($keylightVRay + ".intensityMult") 20;
//////	setAttr ($keylightVRay + ".subdivs") 12;
//////	setAttr ($keylightVRay + ".invisible") 1;
//////
//////	$keylightTooVRay = `shadingNode -asLight VRayLightRectShape`;
//////	setAttr ($keylightTooVRay + ".uSize") 90;
//////	setAttr ($keylightTooVRay + ".vSize") 90;
//////	move -r -ls -wd 0 0 316.253358 ;
//////	move -r -ls -wd -245.614804 0 0 ;
//////	rotate -r -os 0 -32.402782 0 ;
//////	setAttr ($keylightTooVRay + ".intensityMult") 12;
//////	setAttr ($keylightTooVRay + ".subdivs") 12;
//////	setAttr ($keylightTooVRay + ".invisible") 1;
//////
//////	global string $domelightVRay;
//////	$domelightVRay = `shadingNode -asLight VRayLightDomeShape`;
//////	setAttr ($domelightVRay + ".subdivs") 16;
//////	setAttr ($domelightVRay + ".intensityMult") .7;
//////	scale -r 28 28 28;
//////	select -d;
//////	
//////	select -r $copyMesh;
//////	warning "new Render Layer Created with temp scene. Click Cleanup button to delete the layer and elements.";
//////	}


//////else if(($matT[1] == "VRayBlendMtl") || ($matT[1] == "VRayMtl") || ($matT[1] == "VRayFastSSS2") || ($matT[1] == "VRayBumpMtl") || ($matT[1] == "VRayLightMtl") || ($matT[1] == "VRayFlakesMtl") || ($matT[1] == "VRayCarPaintMtl") )
//////	{
	global string $myTempVRayMatSelection;
	string $resultToo[] = `ls -sl`;
	//global string $currentRenderLayer; 
	$currentRenderLayer = `editRenderLayerGlobals -q -crl`;
	$myTempVRayMatSelection = $resultToo[0];
	global string $tempRL;
	$tempRL = `createRenderLayer -mc -name ($myTempVRayMatSelection + "_materialworker") -number 1 -empty`;

	if ($sphereState)
		{
		string $resultX[] = `polySphere -r 50`;
		$dummySphereYo = $resultX[0];
		hyperShade -assign $myTempVRayMatSelection $dummySphereYo;
		if (($cubeState) || ($cylinderState))
			{setAttr ($dummySphereYo + ".translateX") -100;}
		}
	if ($cubeState)
		{
		string $resultY[] = `polyCube -w 100 -h 100 -d 100 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 1`;
		$dummyCubeYo = $resultY[0];
		hyperShade -assign $myTempVRayMatSelection $dummyCubeYo;
		if (($sphereState) || ($cylinderState))
			{setAttr ($dummyCubeYo + ".translateX") 130;}
		}
	if ($cylinderState)
		{
		string $resultZ[] = `polyCylinder -r 20 -h 100 -sx 20 -sy 1 -sz 1 -ax 0 1 0 -rcp 0 -cuv 3 -ch 1`;
		$dummyCylinderYo = $resultZ[0];
		hyperShade -assign $myTempVRayMatSelection $dummyCylinderYo;
		}
	if ($planeState)
		{
		string $resultX[] = `polyPlane -w 100 -h 100 -sx 1 -sy 1 -ax 0 1 0 -cuv 2 -ch 1`;
		$dummyPlaneYo = $resultX[0];
		hyperShade -assign $myTempVRayMatSelection $dummyPlaneYo;
		if (($cubeState) || ($cylinderState) || ($sphereState))
			{setAttr ($dummyPlaneYo + ".translateX") -200;}
		}
	$currentCam = `getCurrentCamera`;
	//$dummyCamera = `camera`;
	lookThru $currentCam; 
	select -d;
	
	if ($sphereState)
		{
		select -add $dummySphereYo;
		}
	if ($cubeState)
		{
		select -add $dummyCubeYo;
		}
	if ($cylinderState)
		{
		select -add $dummyCylinderYo;
		}
	if ($planeState)
		{
		select -add $dummyPlaneYo;
		}	
	viewFit $currentCam;
	select -d;
	global string $keylightVRay;
	global string $keylightTooVRay;

	$keylightVRay = `shadingNode -asLight VRayLightRectShape`;
	setAttr ($keylightVRay + ".uSize") 90;
	setAttr ($keylightVRay + ".vSize") 90;
	move -r 67.263518 75.969143 -79.780579 ;
	rotate -r -os -61.12128 52.322899 -25.536819 ;
	rotate -r -os -36.251101 38.915846 -6.591787 ;
	rotate -r -os -10.578263 11.798781 1.01574 ;
	rotate -r -os 12.168729 -12.133367 -5.3062 ;
	move -r -os -wd 0 0 149.264805 ;
	move -r 85 101 -74 ;
	setAttr ($keylightVRay + ".intensityMult") 20;
	setAttr ($keylightVRay + ".subdivs") 12;
	setAttr ($keylightVRay + ".invisible") 1;

	$keylightTooVRay = `shadingNode -asLight VRayLightRectShape`;
	setAttr ($keylightTooVRay + ".uSize") 90;
	setAttr ($keylightTooVRay + ".vSize") 90;
	move -r -ls -wd 0 0 316.253358 ;
	move -r -ls -wd -245.614804 0 0 ;
	rotate -r -os 0 -32.402782 0 ;
	setAttr ($keylightTooVRay + ".intensityMult") 12;
	setAttr ($keylightTooVRay + ".subdivs") 12;
	setAttr ($keylightTooVRay + ".invisible") 1;

	global string $domelightVRay;
	$domelightVRay = `shadingNode -asLight VRayLightDomeShape`;
	setAttr ($domelightVRay + ".subdivs") 16;
	setAttr ($domelightVRay + ".intensityMult") .7;
	scale -r 28 28 28;
	select -d;
	
	select -r $myTempVRayMatSelection;
	warning "new Render Layer Created with temp scene. Click Cleanup button to delete the layer and elements.";
	
//////	}
openAEWindow;
source "dagMenuProc.mel"; showSG (stringArrayToString (`ls -sl`, ""));
//else
//	{
//	error "Select a V-Ray Material, Utility Node or Mesh and try again.";
//	}

}

global proc openImagesFolder()
{

string $basedir = `workspace -q -rd`;
if( `about -win`)
	{
	string $s=("images");
	string $t=`workspace -q -rd`;
	string $x=`toNativePath $t`;
	string $f=($x+$s);
	system ("start explorer \""+$f+"\"");
	}
else if( `about -mac`)
	{
	system ("open \"" + $basedir + "images\" &"); 
	}
else if( `about -linux64`)
	{
	system ("gnome-open \"" + $basedir + "images\" &"); 
	}
}

global proc toggleEnvTexture()
{
//layer visibility:
setAttr "vraySettings.cam_viewportTexEnable" (!`getAttr "vraySettings.cam_viewportTexEnable"`);
}

//string $selectedCam[] = `ls -sl -type transform`;
global proc lightMatBackPlate()
{
string $selectedCam[] = `ls -sl -dag`;
string $cammy = $selectedCam[0];
global string $homeNameCammyNew;
$homeNameCammyNew = `cameraView -camera $cammy`;
string $tempLocator[] = `spaceLocator -p 0 0 0`;
viewFit;
select -r $cammy;
if ($selectedCam[0] == "")
	{
	error "Select a camera and run script again.";
	}

string $plateBack[] = `polyPlane -w 80 -h 80 -sx 1 -sy 1 -ax 0 0 1 -cuv 2 -ch 1`;//create plane
select -af $selectedCam[0];
orientConstraint -offset 0 0 0 -weight 1;//orientconstraint
select -r $selectedCam[0];
select -add $plateBack[0];
parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z -weight 1;
ConvertSelectionToVertices;
move -r -os -wd 0 0 -1000 ;

cameraView -e -camera $cammy -sc $homeNameCammyNew;
delete $tempLocator;
ConvertSelectionToFaces;
ConvertSelectionToVertices;
}

global proc exposureButtonAction()
{
string $mySelection[] = `ls -sl`;
string $vrLightShape[] = `listRelatives -s $mySelection[0]`;
float $vrayLightValue;
float $vrayLightValueRGB[];
float $adjust;
float $newValue;
float $newValueRGB[];
float $exposureSetting = `floatSliderGrp -q -value exposureSlider1`;
string $typeTest[] = `ls -sl -showType`;
	if ( `size $mySelection` < 1 )
		{
		error "You need to select a single V-Ray light, Light Material or V-Ray Material.";
		}
	else
		{
		if (($typeTest[1] == "VRayLightDomeShape") || ($typeTest[1] == "transform") || ($typeTest[1] == "VRaySunShape") || ($typeTest[1] == "VRayLightRectShape") || ($typeTest[1] == "VRayLightSphereShape") || ($typeTest[1] == "VRayLightIESShape") || ($typeTest[1] == "spotLight") || ($typeTest[1] == "pointLight") || ($typeTest[1] == "areaLight") || ($typeTest[1] == "directionalLight"))
			{
			$vrayLightValue = `getAttr ($vrLightShape[0] + ".intensityMult")`; //RGB value prior to exposure adjustment 
			$adjust = `pow 2 $exposureSetting`; //each stop doubles or halves the intensity of light. this figure out the intensity to multiply by. 
			$newValue = $vrayLightValue * $adjust;// multiply the intensity of the light.;
			setAttr ($vrLightShape[0] + ".intensityMult") $newValue;
			warning ("Changed Exposure value for " + $vrLightShape[0]);
			}
		else if ($typeTest[1] == "VRayLightMtl")
			{
			$vrayLightValue = `getAttr ($vrLightShape[0] + ".colorMultiplier")`;
			$adjust = `pow 2 $exposureSetting`; //each stop doubles or halves the intensity of light. this figure out the intensity to multiply by. 
			$newValue = $vrayLightValue * $adjust;// multiply the intensity of the light.;
			setAttr ($vrLightShape[0] + ".colorMultiplier") $newValue;
			warning ("Changed Exposure value for " + $vrLightShape[0]);
			}
		else if ($typeTest[1] == "VRaySky")
			{
			$vrayLightValue = `getAttr ($vrLightShape[0] + ".intensityMult")`;
			$adjust = `pow 2 $exposureSetting`; //each stop doubles or halves the intensity of light. this figure out the intensity to multiply by. 
			$newValue = $vrayLightValue * $adjust;// multiply the intensity of the light.;
			setAttr ($vrLightShape[0] + ".intensityMult") $newValue;
			warning ("Changed Exposure value for " + $vrLightShape[0]);
			}
		else if ($typeTest[1] == "VRaySunShape")
			{
			$vrayLightValue = `getAttr ($vrLightShape[0] + ".intensityMult")`;
			$adjust = `pow 2 $exposureSetting`; //each stop doubles or halves the intensity of light. this figure out the intensity to multiply by. 
			$newValue = $vrayLightValue * $adjust;// multiply the intensity of the light.;
			setAttr ($vrLightShape[0] + ".intensityMult") $newValue;
			warning ("Changed Exposure value for " + $vrLightShape[0]);
			}
		else if ($typeTest[1] == "VRayMtl")
			{
			$vrayLightValueRGB = `getAttr ($vrLightShape[0] + ".illumColor")`;
			$adjust = `pow 2 $exposureSetting`; //each stop doubles or halves the intensity of light. this figure out the intensity to multiply by. 
			$newValueRGB[0] = $vrayLightValueRGB[0] * $adjust;// multiply the intensity of the light.;
			$newValueRGB[1] = $vrayLightValueRGB[1] * $adjust;// multiply the intensity of the light.;
			$newValueRGB[2] = $vrayLightValueRGB[2] * $adjust;// multiply the intensity of the light.;
			setAttr ($vrLightShape[0] + ".illumColor") $newValueRGB[0] $newValueRGB[1] $newValueRGB[2];
			warning ("Changed Exposure value for " + $vrLightShape[0]);
			}
	}	
}

global proc setExposurer()
{	
if ( `window -exists setExposure` )
  deleteUI -window setExposure;
string $setExposure = `window setExposure`;

//GUI
columnLayout;
$exposureSlider = `floatSliderGrp -precision 2 -field 1 -min -10 -max 10 exposureSlider1`;
button -l "Set Exposure" -c "exposureButtonAction";
showWindow $setExposure;
}

global proc pasted__bGon()
{
uniqueNamer;
string $pasted[] = `ls "pasted__*"`;
string $object;
for ( $object in $pasted )
{
string $elements[];
tokenize( $object, "|", $elements );
string $stripped = $elements[ `size $elements` - 1 ];
$stripped = `substitute "pasted__" $stripped ""`;
catchQuiet(`evalEcho("rename " + $object + " " + $stripped)`);
}
}

global proc uniqueColourMe()
{
string $mySelection[] = `ls -sl`;
int $totalOBJs = `size($mySelection)`;
float $spectrumDivisions = 1.0/$totalOBJs;

	for ($n=0 ; $n<size($mySelection) ; $n++)
	{
		string $mySelectionShapes[] = `listRelatives -s $mySelection[$n]`;
		string $sGroupTempToCopy[] = `listSets -type 1 -o $mySelectionShapes[0]`;
		string $material[] = `listConnections ($sGroupTempToCopy[0] + ".surfaceShader")`;
		float $rgbVal[] = `hsv_to_rgb <<$spectrumDivisions*$n, 1, 1>>`;
		setAttr ($material[0] + ".color") -type double3 $rgbVal[0] $rgbVal[1] $rgbVal[2];
	}
}

global proc matIDMatcher()
{
string $mySelection[] = `ls -sl`;
string $mySelectionType[] = `ls -sl -showType`;
int $totalOBJs = `size($mySelection)`;

if(($mySelectionType[1] == "VRayBlendMtl") || ($mySelectionType[1] == "VRayMtl") || ($mySelectionType[1] == "VRayFastSSS2") || ($mySelectionType[1] == "VRayBumpMtl") || ($mySelectionType[1] == "VRayLightMtl") || ($mySelectionType[1] == "VRayFlakesMtl") ) 
	{
		for ($n=0 ; $n<size($mySelection) ; $n++)
		{
			vray addAttributesFromGroup $mySelection[$n] vray_material_id 1;
			vrayAddAttr $mySelection[$n] vrayColorId;
			vrayAddAttr $mySelection[$n] vrayMaterialId;
			float $lastMatID[] = `getAttr ($mySelection[$totalOBJs - 1] + ".vrayColorId")`;
			setAttr ($mySelection[$n] + ".vrayColorId") -type double3 $lastMatID[0] $lastMatID[1] $lastMatID[2];
		}
	}	
}

global proc matIDMe()
{
string $mySelection[] = `ls -sl`;
string $mySelectionType[] = `ls -sl -showType`;
int $totalOBJs = `size($mySelection)`;
float $spectrumDivisions = 1.0/$totalOBJs;

if ($mySelectionType[1] == "transform")
	{
		for ($n=0 ; $n<size($mySelection) ; $n++)
		{
			string $mySelectionShapes[] = `listRelatives -s $mySelection[$n]`;
			string $sGroupTempToCopy[] = `listSets -type 1 -o $mySelectionShapes[0]`;
			string $surfaceShader[] = `listConnections ($sGroupTempToCopy[0] + ".surfaceShader")`;
			vray addAttributesFromGroup $surfaceShader[0] vray_material_id 1;
			vrayAddAttr $surfaceShader[0] vrayColorId;
			vrayAddAttr $surfaceShader[0] vrayMaterialId;
			float $rgbVal[] = `hsv_to_rgb <<$spectrumDivisions*$n, 1, 1>>`;
			setAttr ($surfaceShader[0] + ".vrayColorId") -type double3 $rgbVal[0] $rgbVal[1] $rgbVal[2];
		}
	}	

else if(($mySelectionType[1] == "VRayBlendMtl") || ($mySelectionType[1] == "VRayMtl") || ($mySelectionType[1] == "VRayFastSSS2") || ($mySelectionType[1] == "VRayBumpMtl") || ($mySelectionType[1] == "VRayLightMtl") || ($mySelectionType[1] == "VRayFlakesMtl") ) 
	{
		for ($n=0 ; $n<size($mySelection) ; $n++)
		{
			vray addAttributesFromGroup $mySelection[$n] vray_material_id 1;
			vrayAddAttr $mySelection[$n] vrayColorId;
			vrayAddAttr $mySelection[$n] vrayMaterialId;
			float $rgbVal[] = `hsv_to_rgb <<$spectrumDivisions*$n, 1, 1>>`;
			setAttr ($mySelection[$n] + ".vrayColorId") -type double3 $rgbVal[0] $rgbVal[1] $rgbVal[2];
		}

	}	
}

global proc lightMapsMenuBuilder()
{
	menu -e -dai lightmapsMenuName;    // EMPTY the menu!
	setParent -m lightmapsMenuName;

	int $IMapMode = `getAttr vraySettings.imap_mode`;
	int $LCMode = `getAttr vraySettings.mode`;
	
//	menuItem -l "Light Cache Auto-setup" -c "lightCacheSetupper";
//	menuItem -d true;

	int $IMapToggleMode0;
		if ($IMapMode == 0)
		{
		$IMapToggleMode0 = 1; 
		}
		else 
		{
		$IMapToggleMode0 = 0; 
		}
	menuItem -checkBox $IMapToggleMode0 -label "Irradiance Map: Single Frame (uncached)" -c "imMode0";

	int $IMapToggleMode1;
		if ($IMapMode == 1)
		{
		$IMapToggleMode1 = 1; 
		}
		else 
		{
		$IMapToggleMode1 = 0; 
		}
	menuItem -checkBox $IMapToggleMode1 -label "Irradiance Map: Multi-frame incremental" -c "imMode1";

	int $IMapToggleMode2;
		if ($IMapMode == 2)
		{
		$IMapToggleMode2 = 1; 
		}
		else 
		{
		$IMapToggleMode2 = 0; 
		}
	menuItem -checkBox $IMapToggleMode2 -label "Irradiance Map: From File" -c "imMode2";

	int $IMapToggleMode3;
		if ($IMapMode == 3)
		{
		$IMapToggleMode3 = 1; 
		}
		else 
		{
		$IMapToggleMode3 = 0; 
		}
	menuItem -checkBox $IMapToggleMode3 -label "Irradiance Map: Add to Current Map" -c "imMode3";

	int $IMapToggleMode4;
		if ($IMapMode == 4)
		{
		$IMapToggleMode4 = 1; 
		}
		else 
		{
		$IMapToggleMode4 = 0; 
		}
	menuItem -checkBox $IMapToggleMode4 -label "Irradiance Map: Incremental Add to Current Map" -c "imMode4";

	int $IMapToggleMode5;
		if ($IMapMode == 5)
		{
		$IMapToggleMode5 = 1; 
		}
		else 
		{
		$IMapToggleMode5 = 0; 
		}
	menuItem -checkBox $IMapToggleMode5 -label "Irradiance Map: Bucket Mode" -c "imMode5";
	
	int $IMapToggleMode6;
		if ($IMapMode == 6)
		{
		$IMapToggleMode6 = 1; 
		}
		else 
		{
		$IMapToggleMode6 = 0; 
		}
	menuItem -checkBox $IMapToggleMode6 -label "Irradiance Map: Animation (prepass)" -c "imMode6";
	
		
	int $IMapToggleMode7;
		if ($IMapMode == 7)
		{
		$IMapToggleMode7 = 1; 
		}
		else 
		{
		$IMapToggleMode7 = 0; 
		}
	menuItem -checkBox $IMapToggleMode7 -label "Irradiance Map: Animation (rendering)" -c "imMode7";
	
menuItem -d true;

	int $LCToggleMode0;
		if ($LCMode == 0)
		{
		$LCToggleMode0 = 1; 
		}
		else 
		{
		$LCToggleMode0 = 0; 
		}
	menuItem -checkBox $LCToggleMode0 -label "Light Cache: Single Frame (uncached)" -c "lcMode0";
	
	int $LCToggleMode1;
		if ($LCMode == 1)
		{
		$LCToggleMode1 = 1; 
		}
		else 
		{
		$LCToggleMode1 = 0; 
		}
	menuItem -checkBox $LCToggleMode1 -label "Light Cache: Fly-through" -c "lcMode1";

	int $LCToggleMode2;
		if ($LCMode == 2)
		{
		$LCToggleMode2 = 1; 
		}
		else 
		{
		$LCToggleMode2 = 0; 
		}
	menuItem -checkBox $LCToggleMode2 -label "Light Cache: From File" -c "lcMode2";

	int $LCToggleMode3;
		if ($LCMode == 3)
		{
		$LCToggleMode3 = 1; 
		}
		else 
		{
		$LCToggleMode3 = 0; 
		}
	menuItem -checkBox $LCToggleMode3 -label "Light Cache: Progressive Path Tracing" -c "lcMode3";
}

global proc rtMenuBuilder()
{
	menu -e -dai rtMenuName;    // EMPTY the menu!
	setParent -m rtMenuName;

	int $rtGPUMode = `getAttr vraySettings.rt_engineType`;
	menuItem -checkBox $rtGPUMode -label "OpenCL GPU Mode" -c "rtEvalGPUMode";
	
	int $rtDisplaceMode = `getAttr vraySettings.rt_displacement`;
	menuItem -checkBox $rtDisplaceMode -label "Displacement" -c "rtEvalDisplacement";
	
	int $rtSubdMode = `getAttr vraySettings.rt_subdivision`;
	menuItem -checkBox $rtSubdMode -label "Subdivision" -c "rtEvalSubdivision";
	
	int $rtProxyMode = `getAttr vraySettings.rt_vrayProxyObjects`;
	menuItem -checkBox $rtProxyMode -label "Proxies" -c "rtEvalProxies";
	
	int $rtHairMode = `getAttr vraySettings.rt_hair`;
	menuItem -checkBox $rtHairMode -label "PaintFX/Hair" -c "rtEvalHair";
	
	int $rtFurMode = `getAttr vraySettings.rt_fur`;
	menuItem -checkBox $rtFurMode -label "Fur" -c "rtEvalFur";
	
	int $rtParticlesMode = `getAttr vraySettings.rt_particleSystems`;
	menuItem -checkBox $rtParticlesMode -label "Particles" -c "rtEvalParticles";
	
	menuItem -d true;

	menuItem -label "RT Multiframe Render Script" -ann "Uses RT as the renderer for multiple animation frames." -c "rtBatchRenderCaller";

	menuItem -label "RT Multiframe Render Script (quality based)" -ann "Uses RT as the renderer for multiple animation frames." -c "rtBatchRenderCallerToQuality";
}

global proc addRoundEdge()
{
float $textRound;
string $resultRoundText = `promptDialog
    -title "Round Edger"
    -message "Enter Round Edge Length:"
    -button "OK" -button "Cancel" 
    -defaultButton "OK" -cancelButton "Cancel"
    -dismissString "Cancel"`;

if ( $resultRoundText == "OK" )
	{
	$textRound = `promptDialog -query -text`;
	//int $textRoundInt = $textRound;
	}
	
	string $selection[] = `ls -sl -dag -lf`; // remember all Shapenodes in selection 
	for ($n=0 ; $n<size($selection) ; $n++)
		{
//		vray addAttributesFromGroup $node vray_roundedges 1;
		vrayAddAttr $selection[$n] vrayRoundEdges;
		vrayAddAttr $selection[$n] vrayRoundEdgesRadius; 
		setAttr ( $selection[$n] + ".vrayRoundEdgesRadius") $textRound;
		}
}

global proc utilitiesMenuBuilder()
{
	menu -e -dai utilitiesMenuName;    // EMPTY the menu!
	setParent -m utilitiesMenuName;

				//menu -label "Utilities" -tearOff false;
				menuItem
					-label "Distributed Render Settings"
					-c "vrayShowDistributedSettings;";
				menuItem
					-label "Revert To Saved Document"
					-c "revertToSaved;";	
				menuItem
					-label "Select all of selected type"
					-ann "Adds a round edge attribute to all selected meshes."
					-c "string $yall[] = `ls -sl -showType`; select (`ls -type $yall[1]`);";
				menuItem
					-label "Add round edges"
					-ann "Adds a round edge attribute to all selected meshes."
					-c "addRoundEdge;";
				menuItem
					-label "Imap Viewer"
					-c "launchImapViewer";
				menuItem
					-label "Render Log/Console"
					-c "Feedback";
				menuItem
					-label "Deex V-Ray Passes to Nuke"
					-ann "Requires Deex V-Ray To Nuke: http://deex.info"
					-c "vrayPassesToNuke";
				menuItem
					-label "Select GI Problem OBJs"
					-ann "Selects meshes with  Visible in Reflections/Refractions flags turned off"
					-c "selectGIProblemOBJs";
				menuItem
					-label "Fix Selected GI Problem OBJs"
					-ann "Turns on Visible in Reflections/Refractions for OBJ files that lost these flags"
					-c "objRenderFix";
				menuItem
					-label "Unique Namer"
					-ann "Renames non-unique items - this fixes name errors that can stop PerLightRender or other scripts that scan your scene nodes from working"
					-c "uniqueNamer";
				menuItem
					-label "Unlock Camera"
					-ann "This removes the lock for cameras that are designated as startup cameras, so they can be deleted."
					-c "unlockCamera";
				menuItem
					-label "Sprite Maker"
					-ann "Creates a plane that's pointed and parented to Persp Camera."
					-c "lightMatBackPlate";
				menuItem
					-label "Make Reflector Card"
					-ann "Creates plane that's pointed to selected object. Used for hidden reflector cards."
					-c "targetCard; repeatLast -ac \"targetCard;\"";
				menuItem
					-label "Strip pasted__ from names"
					-ann "This removes all occurances of pasted__ from all scene nodes."
					-c "pasted__bGon; repeatLast -ac \"pasted__bGon;\"";		
				menuItem
					-label "Open images folder"
					-ann "Opens images folder for active project in Desktop."
					-c "openImagesFolder";		
				menuItem
					-label "Transfer UVs"
					-ann "Select source first and all targets after that and run script."
					-c "UVTransferMeVR";		
				
					
				menuItem -d true;
				
				menuItem
					-label "Send to Command Line Render, no sleep after"
					-ann "Kind of like batch render with current cam/frame range/resolution percentage in scene but uses the command line."
					-c "commandLinerNoSleep";
				menuItem
					-label "Send to Command Line Render, then put CPU to sleep"
					-ann "Kind of like batch render with current cam/frame range/resolution percentage in scene but uses the command line."
					-c "commandLinerSleep";
				menuItem
					-label "Create/Append to Command Line Render File on Desktop"
					-ann "Kind of like batch render with current cam/frame range/resolution percentage in scene but uses the command line."
					-c "commandLinerJustJobFile";
				menuItem
					-label "Trash Command Line Render File on Desktop"
					-ann "Moves command line render job text file to trash."
					-c "trashJustJobFile";
				menuItem
					-label "Append Sleep Command to Render File on Desktop"
					-ann "Puts a sleep after command line render jobs in text file."
					-c "appendSleepCommand";
				menuItem
					-label "Send to Command Line Render with Region Render, no sleep after"
					-ann "Kind of like batch render with current cam/frame range/resolution percentage in scene but uses the command line."
					-c "commandLinerRegionRenderer";
				menuItem
					-label "Send to Command Line Render with Region Render, sleep after"
					-ann "Kind of like batch render with current cam/frame range/resolution percentage in scene but uses the command line."
					-c "commandLinerRegionRenderSleep";
				menuItem
					-label "Send to Command Line Render File with Region Render to Desktop"
					-ann "."
					-c "commandLinerRegionRendererDesktop";
				menuItem
					-label "Tiled Command Line Render, no sleep after"
					-ann "."
					-c "commandLinerTiledRenderer";
				
				menuItem -d true;
				menuItem
					-label "Per-Light Render"
					-c "perLightRender";
				menuItem
					-label "Per-Light Render With System Sleep at End"
					-c "perLightRender; sleeper";
				menuItem
					-label "Per-Light Render Exposure Tweak"
					-ann "Select your V-Ray Light or mesh with V-Ray Light Mat to Adjust values based on exposure stops"
					-c "setExposurer";
//				menuItem
//					-label "Toggle Env Texture"
//					-c "toggleEnvTexture";
}

global proc unlockCamera()
{
string $mySelection[] = `ls -sl`;
camera -e -startupCamera false $mySelection[0];
}

global proc wrapInBlendFresnel()
{
string $mySelection[] = `ls -sl`;
string $shapes[] = `listRelatives -s $mySelection[0]`;
string $sGroup[] = `listSets -type 1 -o $shapes[0]`;
string $currentSurfaceShader[] = `listConnections ($sGroup[0] + ".surfaceShader")`;

//working single-object script
string $blendMatNew = `shadingNode -asShader VRayBlendMtl`;
connectAttr -force ($currentSurfaceShader[0] + ".outColor") ($blendMatNew + ".base_material");
string $fresnelCoater = `shadingNode -asShader VRayMtl`;
setAttr ($fresnelCoater + ".reflectionSubdivs") 22;
connectAttr -force ($fresnelCoater + ".outColor") ($blendMatNew + ".coat_material_0");
setAttr ($fresnelCoater + ".color") -type double3 0 0 0 ;
setAttr ($fresnelCoater + ".reflectionColor") -type double3 0.97 0.97 0.97 ;
string $blendFres = `shadingNode -asTexture VRayFresnel`;
connectAttr -force ($blendFres + ".outColor") ($blendMatNew + ".blend_amount_0");
select -r $mySelection[0];
hyperShade -assign $blendMatNew $mySelection[0];
expression -string ($fresnelCoater + ".bumpMult = " + $currentSurfaceShader[0] + ".bumpMult") -ae 1 -uc all;
setAttr ($currentSurfaceShader[0] + ".bumpShadows") 1;
setAttr ($fresnelCoater + ".bumpShadows") 1;

rename $blendMatNew ($currentSurfaceShader[0] + "_FresnelBlendMat");
rename $fresnelCoater ($currentSurfaceShader[0] + "_coat");
}

global proc commandLinerSleep()
{
//string $basedir = `workspace -q -rd`;
string $sleepCommand = "";
string $exampleFileName = "";

$threadCounter = `threadCount -q -n`;
$resmenuSelection = `optionMenuGrp -q -v resMenu`;
$fullResWidth = `getAttr defaultResolution.width`;
$fullResHeight = `getAttr defaultResolution.height`;
string $projectDir = `workspace -q -rd`;
string $currentScenePath = `file -q -sn` ;  
int $currentResWidth = `getAttr "vraySettings.width"`;
int $currentResHeight = `getAttr "vraySettings.height"`;
setAttr vraySettings.numPasses $threadCounter;
int $renderPercent;
float $setRenderWidth = `getAttr vraySettings.width`;
float $setRenderHeight = `getAttr vraySettings.height`;
float $renderPrintFactor;
int $frameStamp = `currentTime -q`;
string $pathToRenderer = "";
string $version = `getApplicationVersionAsFloat`;

float $dmcThresh = `getAttr vraySettings.dmcThreshold`;
string $dmcThreshMEL = ("setAttr vraySettings.dmcThreshold " + $dmcThresh);
float $dmcs_Adapt = `getAttr vraySettings.dmcs_adaptiveAmount`;
string $dmcs_AdaptMEL = ("setAttr vraySettings.dmcs_adaptiveAmount " + $dmcs_Adapt);
float $dmcs_adaptiveThreshold = `getAttr vraySettings.dmcs_adaptiveThreshold`;
string $dmcs_adaptiveThresholdMEL = ("setAttr vraySettings.dmcs_adaptiveThreshold " + $dmcs_adaptiveThreshold);
int $dmcMaxSubdivs = `getAttr vraySettings.dmcMaxSubdivs`;
string $dmcMaxSubdivsMEL = ("setAttr vraySettings.dmcMaxSubdivs " + $dmcMaxSubdivs);
int $dmcMinSubdivs = `getAttr vraySettings.dmcMinSubdivs`;
string $dmcMinSubdivsMEL = ("setAttr vraySettings.dmcMinSubdivs " + $dmcMinSubdivs);
int $imap_currentPreset = `getAttr vraySettings.imap_currentPreset`;
string $imap_currentPresetMEL = ("setAttr vraySettings.imap_currentPreset " + $imap_currentPreset);
//prompt to save first
string $resulert = `confirmDialog -title "Confirm" -message "Save file first?" 
     -button "Yes" -button "No" -defaultButton "Yes" 
     -cancelButton "No" -dismissString "No"`;

if ($resulert == "Yes") 
	{
	file -f -save;
	}


////Make absolute path to cl app for people without PATH variable set up:
if ( `about -mac` )
	{
	 $pathToRenderer = (("/Applications/Autodesk/maya" + $version + "/Maya.app/Contents/MacOS/") + "Render");
	}
	else if ( `about -linux64` )
	{
	$pathToRenderer = (("/usr/autodesk/maya") + $version + ("-x64/bin/Render"));
	}
	else if ( `about -win` )
	{
	 $pathToRenderer =  ("\"C\:\\Program\ Files\\Autodesk\\Maya" + $version + ("\\bin\\Render.exe") + "\"");
	}

if ( $resmenuSelection == "10%")
		$renderPercent = 2;
	else if ( $resmenuSelection == "25%")
		$renderPercent = 3;
	else if ( $resmenuSelection == "50%")
		$renderPercent = 4;
	else if ( $resmenuSelection == "75%")
		$renderPercent = 5;
	else if ( $resmenuSelection == "100%")
		$renderPercent = 1;
	else if ( $resmenuSelection == "110%")
		$renderPercent = 6;
	else if ( $resmenuSelection == "125%")
		$renderPercent = 7;
	else if ( $resmenuSelection == "150%")
		$renderPercent = 8;

if ( $renderPercent == 2 )
		$renderPrintFactor = 0.10;
	else if ( $renderPercent == 3)
		$renderPrintFactor = 0.25;
	else if ( $renderPercent == 4)
		$renderPrintFactor = 0.5;
	else if ( $renderPercent == 5)
		$renderPrintFactor = 0.75;
	else if ( $renderPercent == 1)
		$renderPrintFactor = 1.0;	
	else if ( $renderPercent == 6)
		$renderPrintFactor = 1.1;
	else if ( $renderPercent == 7)
		$renderPrintFactor = 1.25;
	else if ( $renderPercent == 8)
		$renderPrintFactor = 1.5;

$finalRenderWidth = ($fullResWidth * $renderPrintFactor);
$finalRenderHeight = ($fullResHeight * $renderPrintFactor);
string $renderContents;
string $version = `getApplicationVersionAsFloat`;
string $startFramer = "";
string $endFramer = "";
string $byFramer = "";
string $catenatedRenderParms = "";

if (`getAttr "defaultRenderGlobals.animation"`)
	{
	$startFramer = ("-s " + `getAttr defaultRenderGlobals.startFrame`);
	$endFramer = (" -e " + `getAttr defaultRenderGlobals.endFrame`);
	$byFramer = (" -b " + `getAttr defaultRenderGlobals.byFrameStep`);
	$catenatedRenderParms = ($startFramer + $endFramer + $byFramer + " ");
	}

//final render contents: 
string $renderContents = ($pathToRenderer + " -r vray " + $catenatedRenderParms + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $finalRenderWidth + " -y " + $finalRenderHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");

//write the render script
//SLEEP COMMANDS APPENDED TO COMMAND LINE RENDER

string $exampleFileName = "";
string $basedir = `workspace -q -rd`;

if ( `about -win`)
	{
	$exampleFileName = ("C:\\vrayTempRenderer.bat"); 
	$sleepCommand = ("%windir%\\system32\\rundll32.exe PowrProf.dll, SetSuspendState 0,1,0");
	$fileId=`fopen $exampleFileName "w"`;
	fprint $fileId $renderContents;
	fprint $fileId $sleepCommand;
	fclose $fileId;

	system ("start C:\\vrayTempRenderer.bat"); 
	}
else if ( `about -mac`)
	{
	$exampleFileName = ("/tmp/vrayTempRenderer.command");
	$sleepCommand = ("osascript -e 'tell application \"Finder\" to sleep'");
	$fileId=`fopen $exampleFileName "w"`;
	fprint $fileId $renderContents;
	fprint $fileId $sleepCommand;
	fclose $fileId;
	
	system ("chmod +x /tmp/vrayTempRenderer.command");
	system ("open -a /Applications/Utilities/Terminal.app /tmp/vrayTempRenderer.command"); 
	}
else if ( `about -linux64`)
	{
	$exampleFileName = ("/tmp/vrayTempRenderer.sh");
	$sleepCommand = ("sudo pm-suspend &");
	$fileId=`fopen $exampleFileName "w"`;
	fprint $fileId $renderContents;
	fprint $fileId $sleepCommand;
	fclose $fileId;
	
	system ("chmod +x /tmp/vrayTempRenderer.sh");
	system ("xterm -e /tmp/vrayTempRenderer.sh"); 
	}
}

global proc sleeper()
{
if ( `about -win`)
	{
	system ("%windir%\\system32\\rundll32.exe PowrProf.dll, SetSuspendState 0,1,0");
	}
else if ( `about -mac`)
	{
	system ("osascript -e 'tell application \"Finder\" to sleep'");
	}
else if ( `about -linux64`)
	{
	system ("sudo pm-suspend &");
	}
}

global proc commandLinerNoSleep()
{
commandLiner();
if( `about -mac`)
	{
	system ("open -a /Applications/Utilities/Terminal.app /tmp/vrayTempRenderer.command"); 
	}
else if( `about -win`)
	{
	system ("start C:\\vrayTempRenderer.bat"); 
	}
else if( `about -linux64`)
	{
	system ("xterm -e /tmp/vrayTempRenderer.sh");  
	}
}

global proc trashJustJobFile()
{
	if( `about -mac`)
	{
	string $s=`getenv "HOME"`;
	system ("mv " + $s + "/Desktop/vrayTempRenderer.command " + $s + "/.Trash/");
	}
	else if( `about -win`)
	{
	string $s=`getenv "USERPROFILE"`;
	$exampleFileName = ($s + "/Desktop/vrayTempRenderer.bat");
	sysFile -delete $exampleFileName;
	}
	else if( `about -linux64`)
	{
	string $s=`getenv "HOME"`;
	system ("rm " + $s + "/Desktop/vrayTempRenderer.sh");
	}
}

global proc appendSleepCommand()
{
string $exampleFileName = "";

if ( `about -mac`)
	{
	string $s=`getenv "HOME"`;
	$exampleFileName = ($s + "/Desktop/vrayTempRenderer.command");
	$sleepCommand = ("osascript -e 'tell application \"Finder\" to sleep'\n");
	$fileId=`fopen $exampleFileName "a"`;
	fprint $fileId $sleepCommand;
	fclose $fileId;
	}
else if( `about -win`)
	{
	string $s=`getenv "USERPROFILE"`;
	$exampleFileName = ($s + "/Desktop/vrayTempRenderer.bat");
	$sleepCommand = ("%windir%\\system32\\rundll32.exe PowrProf.dll, SetSuspendState 0,1,0");
	$fileId=`fopen $exampleFileName "a"`;
	fprint $fileId $sleepCommand;
	fclose $fileId;
	}
else if ( `about -linux64`)
	{
	string $s = `getenv "HOME"`;
	$exampleFileName = ($s + "/Desktop/vrayTempRenderer.sh");
	$sleepCommand = ("sudo pm-suspend &\n");
	$fileId=`fopen $exampleFileName "a"`;
	fprint $fileId $sleepCommand;
	fclose $fileId;
	}
}

global proc commandLinerJustJobFile()
{
$threadCounter = `threadCount -q -n`;
$resmenuSelection = `optionMenuGrp -q -v resMenu`;
$fullResWidth = `getAttr defaultResolution.width`;
$fullResHeight = `getAttr defaultResolution.height`;
string $projectDir = `workspace -q -rd`;
string $currentScenePath = `file -q -sn` ;  
int $currentResWidth = `getAttr "vraySettings.width"`;
int $currentResHeight = `getAttr "vraySettings.height"`;
setAttr vraySettings.numPasses $threadCounter;
int $renderPercent;
float $setRenderWidth = `getAttr vraySettings.width`;
float $setRenderHeight = `getAttr vraySettings.height`;
float $renderPrintFactor;
int $frameStamp = `currentTime -q`;
string $pathToRenderer = "";
string $version = `getApplicationVersionAsFloat`;

float $dmcThresh = `getAttr vraySettings.dmcThreshold`;
string $dmcThreshMEL = ("setAttr vraySettings.dmcThreshold " + $dmcThresh);
float $dmcs_Adapt = `getAttr vraySettings.dmcs_adaptiveAmount`;
string $dmcs_AdaptMEL = ("setAttr vraySettings.dmcs_adaptiveAmount " + $dmcs_Adapt);
float $dmcs_adaptiveThreshold = `getAttr vraySettings.dmcs_adaptiveThreshold`;
string $dmcs_adaptiveThresholdMEL = ("setAttr vraySettings.dmcs_adaptiveThreshold " + $dmcs_adaptiveThreshold);
int $dmcMaxSubdivs = `getAttr vraySettings.dmcMaxSubdivs`;
string $dmcMaxSubdivsMEL = ("setAttr vraySettings.dmcMaxSubdivs " + $dmcMaxSubdivs);
int $dmcMinSubdivs = `getAttr vraySettings.dmcMinSubdivs`;
string $dmcMinSubdivsMEL = ("setAttr vraySettings.dmcMinSubdivs " + $dmcMinSubdivs);
int $imap_currentPreset = `getAttr vraySettings.imap_currentPreset`;
string $imap_currentPresetMEL = ("setAttr vraySettings.imap_currentPreset " + $imap_currentPreset);
//prompt to save first
string $resulert = `confirmDialog -title "Confirm" -message "Save file first?" 
     -button "Yes" -button "No" -defaultButton "Yes" 
     -cancelButton "No" -dismissString "No"`;

if ($resulert == "Yes") 
	{
	file -f -save;
	}

////Make absolute path to cl app for people without PATH variable set up:
if ( `about -mac` )
	{
	 $pathToRenderer = (("/Applications/Autodesk/maya" + $version + "/Maya.app/Contents/MacOS/") + "Render");
	}
	else if ( `about -linux64` )
	{
	$pathToRenderer = (("/usr/autodesk/maya") + $version + ("-x64/bin/Render"));
	}
	else if ( `about -win` )
	{
	 $pathToRenderer =  ("\"C\:\\Program\ Files\\Autodesk\\Maya" + $version + ("\\bin\\Render.exe") + "\"");
	}

if ( $resmenuSelection == "10%")
		$renderPercent = 2;
	else if ( $resmenuSelection == "25%")
		$renderPercent = 3;
	else if ( $resmenuSelection == "50%")
		$renderPercent = 4;
	else if ( $resmenuSelection == "75%")
		$renderPercent = 5;
	else if ( $resmenuSelection == "100%")
		$renderPercent = 1;
	else if ( $resmenuSelection == "110%")
		$renderPercent = 6;
	else if ( $resmenuSelection == "125%")
		$renderPercent = 7;
	else if ( $resmenuSelection == "150%")
		$renderPercent = 8;

if ( $renderPercent == 2 )
		$renderPrintFactor = 0.10;
	else if ( $renderPercent == 3)
		$renderPrintFactor = 0.25;
	else if ( $renderPercent == 4)
		$renderPrintFactor = 0.5;
	else if ( $renderPercent == 5)
		$renderPrintFactor = 0.75;
	else if ( $renderPercent == 1)
		$renderPrintFactor = 1.0;	
	else if ( $renderPercent == 6)
		$renderPrintFactor = 1.1;
	else if ( $renderPercent == 7)
		$renderPrintFactor = 1.25;
	else if ( $renderPercent == 8)
		$renderPrintFactor = 1.5;

$finalRenderWidth = ($fullResWidth * $renderPrintFactor);
$finalRenderHeight = ($fullResHeight * $renderPrintFactor);
string $renderContents;
string $version = `getApplicationVersionAsFloat`;
string $startFramer = "";
string $endFramer = "";
string $byFramer = "";
string $catenatedRenderParms = "";

if (`getAttr "defaultRenderGlobals.animation"`)
	{
	$startFramer = ("-s " + `getAttr defaultRenderGlobals.startFrame`);
	$endFramer = (" -e " + `getAttr defaultRenderGlobals.endFrame`);
	$byFramer = (" -b " + `getAttr defaultRenderGlobals.byFrameStep`);
	$catenatedRenderParms = ($startFramer + $endFramer + $byFramer + " ");
	}

//final render contents: 
string $namen = `file -q -sn -shn`;
string $buffer[];
$sceneNameNoExtension = `tokenize $namen "." $buffer`;
string $renderContents = ($pathToRenderer + " -r vray " + $catenatedRenderParms + "-im \"" + $buffer[0] + "\" -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $finalRenderWidth + " -y " + $finalRenderHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");

//write the render script
string $exampleFileName = "";
string $basedir = `workspace -q -rd`;
if( `about -win`)
	{
	string $s=`getenv "USERPROFILE"`;
	$exampleFileName = ($s + "/Desktop/vrayTempRenderer.bat");
	}
else if( `about -mac`)
	{
	string $s = `getenv "HOME"`;
	$exampleFileName = ($s + "/Desktop/vrayTempRenderer.command");
	}
else if( `about -linux64`)
	{
	string $s = `getenv "HOME"`;
	$exampleFileName = ($s + "/Desktop/vrayTempRenderer.sh");
	}

//touch the file if it doesn't exist
if( `about -mac`)
	{
	string $s = `getenv "HOME"`;
	system ("touch " + $s + "/Desktop/vrayTempRenderer.command &"); 
	}
else if( `about -win`)
	{
	string $s=`getenv "USERPROFILE"`;
	$exampleFileName = ($s + "/Desktop/vrayTempRenderer.bat");
	$touchCommand = (" \n");
	int $fileExists = `file -q -exists $exampleFileName`;
		if (($fileExists) == 0)
		{
		$fileId=`fopen $exampleFileName "w"`;
		fprint $fileId $touchCommand;
		fclose $fileId;
		}
	}
else if( `about -linux64`)
	{
	string $s = `getenv "HOME"`;
	system ("touch " + $s + "/Desktop/vrayTempRenderer.sh &"); 
	}

$fileId=`fopen $exampleFileName "a"`;
fprint $fileId $renderContents;
if( `about -mac`)
	{
	string $opener = "open \"" + $projectDir + "images\"\n";
	fprint $fileId $opener;
	}
fclose $fileId;

if( `about -mac`)
	{
	system ("echo growlnotify -n \"Maya Render\" -I /Applications/Autodesk/maya" + $version + "/Maya.app -m Maya Render Done! >> ~/Desktop/vrayTempRenderer.command");
	system ("chmod +x ~/Desktop/vrayTempRenderer.command");
	}
else if ( `about -linux64`)
	{
	system ("chmod +x ~/Desktop/vrayTempRenderer.sh");
	}
}

global proc commandLinerRegionRenderSleep()
{
//string $basedir = `workspace -q -rd`;
string $sleepCommand = "";
string $exampleFileName = "";

$threadCounter = `threadCount -q -n`;
$resmenuSelection = `optionMenuGrp -q -v resMenu`;
$fullResWidth = `getAttr defaultResolution.width`;
$fullResHeight = `getAttr defaultResolution.height`;
string $projectDir = `workspace -q -rd`;
string $currentScenePath = `file -q -sn` ;  
int $currentResWidth = `getAttr "vraySettings.width"`;
int $currentResHeight = `getAttr "vraySettings.height"`;
setAttr vraySettings.numPasses $threadCounter;
int $renderPercent;
float $setRenderWidth = `getAttr vraySettings.width`;
float $setRenderHeight = `getAttr vraySettings.height`;
float $renderPrintFactor;
int $frameStamp = `currentTime -q`;
string $pathToRenderer = "";
string $version = `getApplicationVersionAsFloat`;

float $dmcThresh = `getAttr vraySettings.dmcThreshold`;
string $dmcThreshMEL = ("setAttr vraySettings.dmcThreshold " + $dmcThresh);
float $dmcs_Adapt = `getAttr vraySettings.dmcs_adaptiveAmount`;
string $dmcs_AdaptMEL = ("setAttr vraySettings.dmcs_adaptiveAmount " + $dmcs_Adapt);
float $dmcs_adaptiveThreshold = `getAttr vraySettings.dmcs_adaptiveThreshold`;
string $dmcs_adaptiveThresholdMEL = ("setAttr vraySettings.dmcs_adaptiveThreshold " + $dmcs_adaptiveThreshold);
int $dmcMaxSubdivs = `getAttr vraySettings.dmcMaxSubdivs`;
string $dmcMaxSubdivsMEL = ("setAttr vraySettings.dmcMaxSubdivs " + $dmcMaxSubdivs);
int $dmcMinSubdivs = `getAttr vraySettings.dmcMinSubdivs`;
string $dmcMinSubdivsMEL = ("setAttr vraySettings.dmcMinSubdivs " + $dmcMinSubdivs);
int $imap_currentPreset = `getAttr vraySettings.imap_currentPreset`;
string $imap_currentPresetMEL = ("setAttr vraySettings.imap_currentPreset " + $imap_currentPreset);
//prompt to save first
string $resulert = `confirmDialog -title "Confirm" -message "Save file first?" 
     -button "Yes" -button "No" -defaultButton "Yes" 
     -cancelButton "No" -dismissString "No"`;

if ($resulert == "Yes") 
	{
	file -f -save;
	}

//REGION RENDERING
int $regOne = `getAttr defaultRenderGlobals.left`;
int $regTwo = `getAttr defaultRenderGlobals.rght`;
int $regThree = `getAttr defaultRenderGlobals.bot`;
int $regFour = `getAttr defaultRenderGlobals.top`;
//END REGION RENDERING

////Make absolute path to cl app for people without PATH variable set up:
if ( `about -mac` )
	{
	 $pathToRenderer = (("/Applications/Autodesk/maya" + $version + "/Maya.app/Contents/MacOS/") + "Render");
	}
	else if ( `about -win` )
	{
	 $pathToRenderer =  ("\"C\:\\Program\ Files\\Autodesk\\Maya" + $version + ("\\bin\\Render.exe") + "\"");
	}

if ( $resmenuSelection == "10%")
		$renderPercent = 2;
	else if ( $resmenuSelection == "25%")
		$renderPercent = 3;
	else if ( $resmenuSelection == "50%")
		$renderPercent = 4;
	else if ( $resmenuSelection == "75%")
		$renderPercent = 5;
	else if ( $resmenuSelection == "100%")
		$renderPercent = 1;
	else if ( $resmenuSelection == "110%")
		$renderPercent = 6;
	else if ( $resmenuSelection == "125%")
		$renderPercent = 7;
	else if ( $resmenuSelection == "150%")
		$renderPercent = 8;

if ( $renderPercent == 2 )
		$renderPrintFactor = 0.10;
	else if ( $renderPercent == 3)
		$renderPrintFactor = 0.25;
	else if ( $renderPercent == 4)
		$renderPrintFactor = 0.5;
	else if ( $renderPercent == 5)
		$renderPrintFactor = 0.75;
	else if ( $renderPercent == 1)
		$renderPrintFactor = 1.0;	
	else if ( $renderPercent == 6)
		$renderPrintFactor = 1.1;
	else if ( $renderPercent == 7)
		$renderPrintFactor = 1.25;
	else if ( $renderPercent == 8)
		$renderPrintFactor = 1.5;

$finalRenderWidth = ($fullResWidth * $renderPrintFactor);
$finalRenderHeight = ($fullResHeight * $renderPrintFactor);
string $renderContents;
string $version = `getApplicationVersionAsFloat`;
string $startFramer = "";
string $endFramer = "";
string $byFramer = "";
string $catenatedRenderParms = "";

if (`getAttr "defaultRenderGlobals.animation"`)
	{
	$startFramer = (" -s " + `getAttr defaultRenderGlobals.startFrame`);
	$endFramer = (" -e " + `getAttr defaultRenderGlobals.endFrame`);
	$byFramer = (" -b " + `getAttr defaultRenderGlobals.byFrameStep`);
	$catenatedRenderParms = ($startFramer + $endFramer + $byFramer + " ");
	}

//final render contents: 
string $renderContents = ($pathToRenderer + " -r vray -reg " + $regOne + " " + $regTwo + " " + $regThree + " " + $regFour + $catenatedRenderParms + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $finalRenderWidth + " -y " + $finalRenderHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");

//SLEEP COMMANDS APPENDED TO COMMAND LINE RENDER

string $exampleFileName = "";
string $basedir = `workspace -q -rd`;

if ( `about -win`)
	{
	$exampleFileName = ("C:\\vrayTempRenderer.bat"); 
	$sleepCommand = ("%windir%\\system32\\rundll32.exe PowrProf.dll, SetSuspendState 0,1,0");
	$fileId=`fopen $exampleFileName "w"`;
	fprint $fileId $renderContents;
	fprint $fileId $sleepCommand;
	fclose $fileId;

	system ("start C:\\vrayTempRenderer.bat"); 
	}
else if ( `about -mac`)
	{
	$exampleFileName = ("/tmp/vrayTempRenderer.command");
	$sleepCommand = ("osascript -e 'tell application \"Finder\" to sleep'\n");
	$fileId=`fopen $exampleFileName "w"`;
	fprint $fileId $renderContents;
	fprint $fileId $sleepCommand;
	fclose $fileId;
	//Dave's personal - opens images folder on render completion
//	string $projectDir = `workspace -q -rd`;
//	system ("echo open \"" + $projectDir + "images\" >> /tmp/vrayTempRenderer.command");
	//end Dave's personal

	system ("chmod +x /tmp/vrayTempRenderer.command");
	system ("open -a /Applications/Utilities/Terminal.app /tmp/vrayTempRenderer.command"); 
	}
else if ( `about -linux64`)
	{
	$exampleFileName = ("/tmp/vrayTempRenderer.sh");
	$sleepCommand = ("sudo pm-suspend &");
	$fileId=`fopen $exampleFileName "w"`;
	fprint $fileId $renderContents;
	fprint $fileId $sleepCommand;
	fclose $fileId;

	system ("chmod +x /tmp/vrayTempRenderer.sh");
	system ("xterm -e /tmp/vrayTempRenderer.sh");  
	}
	
}

global proc commandLinerRegionRendererDesktop()
{
commandLinerRegionRender();

if( `about -mac`)
	{
	system ("mv /tmp/vrayTempRenderer.command ~/Desktop/"); 
	}
else if( `about -win`)
	{
	error "sorry – this works in Linux and OS X only";
	}
else if( `about -linux64`)
	{
	system ("mv /tmp/vrayTempRenderer.command ~/Desktop/");  
	}
}

global proc commandLinerRegionRenderer()
{
commandLinerRegionRender();
//Dave's personal - opens images folder on render completion
//string $projectDir = `workspace -q -rd`;
//system ("echo open \"" + $projectDir + "images\" >> /tmp/vrayTempRenderer.command");
//end Dave's personal

if( `about -mac`)
	{
	system ("open -a /Applications/Utilities/Terminal.app /tmp/vrayTempRenderer.command"); 
	}
else if( `about -win`)
	{
	system ("start C:\\vrayTempRenderer.bat"); 
	}
else if( `about -linux64`)
	{
	system ("xterm -e /tmp/vrayTempRenderer.sh");  
	}
}

global proc commandLinerTiledRenderer()
{
string $projectDir = `workspace -q -rd`;

$threadCounter = `threadCount -q -n`;
$resmenuSelection = `optionMenuGrp -q -v resMenu`;
$currentResWidth = `getAttr defaultResolution.width`;
$currentResHeight = `getAttr defaultResolution.height`;
string $projectDir = `workspace -q -rd`;
string $currentScenePath = `file -q -sn` ;  
setAttr vraySettings.numPasses $threadCounter;
int $frameStamp = `currentTime -q`;
string $pathToRenderer = "";
string $version = `getApplicationVersionAsFloat`;

float $dmcThresh = `getAttr vraySettings.dmcThreshold`;
string $dmcThreshMEL = ("setAttr vraySettings.dmcThreshold " + $dmcThresh);
float $dmcs_Adapt = `getAttr vraySettings.dmcs_adaptiveAmount`;
string $dmcs_AdaptMEL = ("setAttr vraySettings.dmcs_adaptiveAmount " + $dmcs_Adapt);
float $dmcs_adaptiveThreshold = `getAttr vraySettings.dmcs_adaptiveThreshold`;
string $dmcs_adaptiveThresholdMEL = ("setAttr vraySettings.dmcs_adaptiveThreshold " + $dmcs_adaptiveThreshold);
int $dmcMaxSubdivs = `getAttr vraySettings.dmcMaxSubdivs`;
string $dmcMaxSubdivsMEL = ("setAttr vraySettings.dmcMaxSubdivs " + $dmcMaxSubdivs);
int $dmcMinSubdivs = `getAttr vraySettings.dmcMinSubdivs`;
string $dmcMinSubdivsMEL = ("setAttr vraySettings.dmcMinSubdivs " + $dmcMinSubdivs);
int $imap_currentPreset = `getAttr vraySettings.imap_currentPreset`;
string $imap_currentPresetMEL = ("setAttr vraySettings.imap_currentPreset " + $imap_currentPreset);

if ( `about -mac` )
	{
	 $pathToRenderer = (("/Applications/Autodesk/maya" + $version + "/Maya.app/Contents/MacOS/") + "Render");
	}
	else if ( `about -linux64` )
	{
	 $pathToRenderer =  (("/usr/autodesk/maya") + $version + ("-x64/bin/Render"));
	}
	else if ( `about -win` )
	{
	 $pathToRenderer =  ("\"C\:\\Program\ Files\\Autodesk\\Maya" + $version + ("\\bin\\Render.exe") + "\"");
	}

string $renderContents;
string $version = `getApplicationVersionAsFloat`;

//prompt for tile divisions
int $text;
string $resultPrompt = `promptDialog
    -title "Tile Count"
    -message "Enter Tile Number (2, 4 or 9 only):"
    -button "OK" -button "Cancel" 
    -defaultButton "OK" -cancelButton "Cancel"
    -dismissString "Cancel"`;

if ($resultPrompt == "OK") 
	{
	$text = `promptDialog -query -text`;
	
	if(($text == "2") || ($text == "4") || ($text == "9"))
			{ 
			string $namen = `file -q -sn -shn`;
			string $buffer[];
			$sceneNameNoExtension = `tokenize $namen "." $buffer`;
			
			float $halfWidthEnd;
			float $halfHeightEnd;
			string $renderContentsOne = "";
			string $renderContentsTwo = "";
			string $renderContentsThree = "";
			string $renderContentsFour = "";
			string $renderContentsFive = "";
			string $renderContentsSix = "";
			string $renderContentsSeven = "";
			string $renderContentsEight = "";
			string $renderContentsNine = "";
			
			if ($text == 2)
				{
				$halfWidthEnd = ($currentResWidth/$text);
				$halfHeightEnd = $currentResHeight;
				$renderContentsOne = ($pathToRenderer + " -r vray -reg " + "0" + " " + $halfWidthEnd + " " + "0" + " " + $halfHeightEnd + " -im \"" + ($buffer[0] + "_tile1\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				$renderContentsTwo = ($pathToRenderer + " -r vray -reg " + $halfWidthEnd + " " + $currentResWidth + " " + "0" + " " + $halfHeightEnd + " -im \"" + ($buffer[0] + "_tile2\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				}
				
			else if ($text == 4)
				{
				$halfWidthEnd = ($currentResWidth/2);
				$halfHeightEnd = ($currentResHeight/2);
				$renderContentsOne = ($pathToRenderer + " -r vray -reg " + "0" + " " + $halfWidthEnd + " " + "0" + " " + $halfHeightEnd + " -im \"" + ($buffer[0] + "_tile1\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				$renderContentsTwo = ($pathToRenderer + " -r vray -reg " + $halfWidthEnd + " " + $currentResWidth + " " + "0" + " " + $halfHeightEnd + " -im \"" + ($buffer[0] + "_tile2\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				$renderContentsThree = ($pathToRenderer + " -r vray -reg " + "0" + " " + $halfWidthEnd + " " + $halfHeightEnd + " " + $currentResHeight + " -im \"" + ($buffer[0] + "_tile3\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				$renderContentsFour = ($pathToRenderer + " -r vray -reg " + $halfWidthEnd + " " + $currentResWidth + " " + $halfHeightEnd + " " + $currentResHeight + " -im \"" + ($buffer[0] + "_tile4\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				}
			else if ($text == 9)
				{
				$halfWidthEnd = ($currentResWidth/3);
				$halfHeightEnd = ($currentResHeight/3);
				$renderContentsOne = ($pathToRenderer + " -r vray -reg " + "0" + " " + $halfWidthEnd + " " + "0" + " " + $halfHeightEnd + " -im \"" + ($buffer[0] + "_tile1\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				$renderContentsTwo = ($pathToRenderer + " -r vray -reg " + $halfWidthEnd + " " + ($halfWidthEnd * 2) + " " + "0" + " " + $halfHeightEnd + " -im \"" + ($buffer[0] + "_tile2\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				$renderContentsThree = ($pathToRenderer + " -r vray -reg " + ($halfWidthEnd * 2) + " " + $currentResWidth + " " + "0" + " " + $halfHeightEnd + " -im \"" + ($buffer[0] + "_tile3\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				$renderContentsFour = ($pathToRenderer + " -r vray -reg " + "0" + " " + $halfWidthEnd + " " + $halfHeightEnd + " " + ($halfHeightEnd * 2) + " -im \"" + ($buffer[0] + "_tile4\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				$renderContentsFive = ($pathToRenderer + " -r vray -reg " + $halfWidthEnd + " " + ($halfWidthEnd * 2) + " " + $halfHeightEnd + " " + ($halfHeightEnd * 2) + " -im \"" + ($buffer[0] + "_tile5\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				$renderContentsSix = ($pathToRenderer + " -r vray -reg " + ($halfWidthEnd * 2) + " " + $currentResWidth + " " + $halfHeightEnd + " " + ($halfHeightEnd * 2) + " -im \"" + ($buffer[0] + "_tile6\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				$renderContentsSeven = ($pathToRenderer + " -r vray -reg " + "0" + " " + $halfWidthEnd + " " + ($halfHeightEnd * 2) + " " + $currentResHeight + " -im \"" + ($buffer[0] + "_tile7\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				$renderContentsEight = ($pathToRenderer + " -r vray -reg " + $halfWidthEnd + " " + ($halfWidthEnd * 2) + " " + ($halfHeightEnd * 2) + " " + $currentResHeight + " -im \"" + ($buffer[0] + "_tile8\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				$renderContentsNine = ($pathToRenderer + " -r vray -reg " + ($halfWidthEnd * 2) + " " + $currentResWidth + " " + ($halfHeightEnd * 2) + " " + $currentResHeight + " -im \"" + ($buffer[0] + "_tile9\"" ) + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $currentResWidth + " -y " + $currentResHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");
				}
			
			//write the render script
			string $exampleFileName = "";
			string $basedir = `workspace -q -rd`;
			if( `about -win`)
				{
				$exampleFileName = ("C:\\vrayTempRenderer.bat"); 
				}
			else if( `about -mac`)
				{
				$exampleFileName = ("/tmp/vrayTempRenderer.command");
				}
			else if( `about -linux64`)
				{
				$exampleFileName = ("/tmp/vrayTempRenderer.sh");
				}
			$fileId=`fopen $exampleFileName "w"`;
			fprint $fileId $renderContentsOne;
			fprint $fileId $renderContentsTwo;
			fprint $fileId $renderContentsThree;
			fprint $fileId $renderContentsFour;
			fprint $fileId $renderContentsFive;
			fprint $fileId $renderContentsSix;
			fprint $fileId $renderContentsSeven;
			fprint $fileId $renderContentsEight;
			fprint $fileId $renderContentsNine;
			
			fclose $fileId;
			
			if( `about -mac`)
				{
				system ("echo growlnotify -n \"Maya Render\" -I /Applications/Autodesk/maya" + $version + "/Maya.app -m Maya Render Done! >> /tmp/vrayTempRenderer.command");
				system ("chmod +x /tmp/vrayTempRenderer.command");
				}
			else if( `about -linux64`)
				{
				system ("chmod +x /tmp/vrayTempRenderer.sh");
				}
			if( `about -mac`)
					{
					system ("open -a /Applications/Utilities/Terminal.app /tmp/vrayTempRenderer.command"); 
					}
				else if( `about -win`)
					{
					system ("start C:\\vrayTempRenderer.bat"); 
					}
				else if( `about -linux64`)
					{
					system ("xterm -e /tmp/vrayTempRenderer.sh");  
					}
			}
		else 
			{
			error "You're bad at reading and 'rithmetic.\n";
			}
	}
	else
	{
	warning "Nothing done.\n";
	}


}

global proc commandLinerRegionRender()
{
$threadCounter = `threadCount -q -n`;
$resmenuSelection = `optionMenuGrp -q -v resMenu`;
$fullResWidth = `getAttr defaultResolution.width`;
$fullResHeight = `getAttr defaultResolution.height`;
string $projectDir = `workspace -q -rd`;
string $currentScenePath = `file -q -sn` ;  
int $currentResWidth = `getAttr "vraySettings.width"`;
int $currentResHeight = `getAttr "vraySettings.height"`;
setAttr vraySettings.numPasses $threadCounter;
int $renderPercent;
float $setRenderWidth = `getAttr vraySettings.width`;
float $setRenderHeight = `getAttr vraySettings.height`;
float $renderPrintFactor;
int $frameStamp = `currentTime -q`;
string $pathToRenderer = "";
string $version = `getApplicationVersionAsFloat`;

float $dmcThresh = `getAttr vraySettings.dmcThreshold`;
string $dmcThreshMEL = ("setAttr vraySettings.dmcThreshold " + $dmcThresh);
float $dmcs_Adapt = `getAttr vraySettings.dmcs_adaptiveAmount`;
string $dmcs_AdaptMEL = ("setAttr vraySettings.dmcs_adaptiveAmount " + $dmcs_Adapt);
float $dmcs_adaptiveThreshold = `getAttr vraySettings.dmcs_adaptiveThreshold`;
string $dmcs_adaptiveThresholdMEL = ("setAttr vraySettings.dmcs_adaptiveThreshold " + $dmcs_adaptiveThreshold);
int $dmcMaxSubdivs = `getAttr vraySettings.dmcMaxSubdivs`;
string $dmcMaxSubdivsMEL = ("setAttr vraySettings.dmcMaxSubdivs " + $dmcMaxSubdivs);
int $dmcMinSubdivs = `getAttr vraySettings.dmcMinSubdivs`;
string $dmcMinSubdivsMEL = ("setAttr vraySettings.dmcMinSubdivs " + $dmcMinSubdivs);
int $imap_currentPreset = `getAttr vraySettings.imap_currentPreset`;
string $imap_currentPresetMEL = ("setAttr vraySettings.imap_currentPreset " + $imap_currentPreset);

string $resulert = `confirmDialog -title "Confirm" -message "Save file first?" 
     -button "Yes" -button "No" -defaultButton "Yes" 
     -cancelButton "No" -dismissString "No"`;

if ($resulert == "Yes") 
	{
	file -f -save;
	}
	
if ( `about -mac` )
	{
	 $pathToRenderer = (("/Applications/Autodesk/maya" + $version + "/Maya.app/Contents/MacOS/") + "Render");
	}
	else if ( `about -linux64` )
	{
	 $pathToRenderer =  (("/usr/autodesk/maya") + $version + ("-x64/bin/Render"));
	}
	else if ( `about -win` )
	{
	 $pathToRenderer =  ("\"C\:\\Program\ Files\\Autodesk\\Maya" + $version + ("\\bin\\Render.exe") + "\"");
	}

//REGION RENDERING
int $regOne = `getAttr defaultRenderGlobals.left`;
int $regTwo = `getAttr defaultRenderGlobals.rght`;
int $regThree = `getAttr defaultRenderGlobals.bot`;
int $regFour = `getAttr defaultRenderGlobals.top`;
//END REGION RENDERING

if ( $resmenuSelection == "10%")
		$renderPercent = 2;
	else if ( $resmenuSelection == "25%")
		$renderPercent = 3;
	else if ( $resmenuSelection == "50%")
		$renderPercent = 4;
	else if ( $resmenuSelection == "75%")
		$renderPercent = 5;
	else if ( $resmenuSelection == "100%")
		$renderPercent = 1;
	else if ( $resmenuSelection == "110%")
		$renderPercent = 6;
	else if ( $resmenuSelection == "125%")
		$renderPercent = 7;
	else if ( $resmenuSelection == "150%")
		$renderPercent = 8;

if ( $renderPercent == 2 )
		$renderPrintFactor = 0.10;
	else if ( $renderPercent == 3)
		$renderPrintFactor = 0.25;
	else if ( $renderPercent == 4)
		$renderPrintFactor = 0.5;
	else if ( $renderPercent == 5)
		$renderPrintFactor = 0.75;
	else if ( $renderPercent == 1)
		$renderPrintFactor = 1.0;	
	else if ( $renderPercent == 6)
		$renderPrintFactor = 1.1;
	else if ( $renderPercent == 7)
		$renderPrintFactor = 1.25;
	else if ( $renderPercent == 8)
		$renderPrintFactor = 1.5;

$finalRenderWidth = ($fullResWidth * $renderPrintFactor);
$finalRenderHeight = ($fullResHeight * $renderPrintFactor);
string $renderContents;
string $version = `getApplicationVersionAsFloat`;
string $renderContents;
string $version = `getApplicationVersionAsFloat`;
string $startFramer = "";
string $endFramer = "";
string $byFramer = "";
string $catenatedRenderParms = "";

if (`getAttr "defaultRenderGlobals.animation"`)
	{
	$startFramer = ("-s " + `getAttr defaultRenderGlobals.startFrame`);
	$endFramer = (" -e " + `getAttr defaultRenderGlobals.endFrame`);
	$byFramer = (" -b " + `getAttr defaultRenderGlobals.byFrameStep`);
	$catenatedRenderParms = ($startFramer + $endFramer + $byFramer + " ");
	}
//final render contents: 
string $renderContents = ($pathToRenderer + " -r vray -reg " + $regOne + " " + $regTwo + " " + $regThree + " " + $regFour + $catenatedRenderParms + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $finalRenderWidth + " -y " + $finalRenderHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");

//write the render script
string $exampleFileName = "";
string $basedir = `workspace -q -rd`;
if( `about -win`)
	{
	$exampleFileName = ("C:\\vrayTempRenderer.bat"); 
	}
else if( `about -mac`)
	{
	$exampleFileName = ("/tmp/vrayTempRenderer.command");
	}
else if( `about -linux64`)
	{
	$exampleFileName = ("/tmp/vrayTempRenderer.sh");
	}
$fileId=`fopen $exampleFileName "w"`;
fprint $fileId $renderContents;
fclose $fileId;

if( `about -mac`)
	{
	system ("echo growlnotify -n \"Maya Render\" -I /Applications/Autodesk/maya" + $version + "/Maya.app -m Maya Render Done! >> /tmp/vrayTempRenderer.command");
	system ("chmod +x /tmp/vrayTempRenderer.command");
	}
else if( `about -linux64`)
	{
	system ("chmod +x /tmp/vrayTempRenderer.sh");
	}
}

global proc commandLiner()
{
$threadCounter = `threadCount -q -n`;
$resmenuSelection = `optionMenuGrp -q -v resMenu`;
$fullResWidth = `getAttr defaultResolution.width`;
$fullResHeight = `getAttr defaultResolution.height`;
string $projectDir = `workspace -q -rd`;
string $currentScenePath = `file -q -sn` ;  
int $currentResWidth = `getAttr "vraySettings.width"`;
int $currentResHeight = `getAttr "vraySettings.height"`;
setAttr vraySettings.numPasses $threadCounter;
int $renderPercent;
float $setRenderWidth = `getAttr vraySettings.width`;
float $setRenderHeight = `getAttr vraySettings.height`;
float $renderPrintFactor;
int $frameStamp = `currentTime -q`;
string $pathToRenderer = "";
string $version = `getApplicationVersionAsFloat`;

float $dmcThresh = `getAttr vraySettings.dmcThreshold`;
string $dmcThreshMEL = ("setAttr vraySettings.dmcThreshold " + $dmcThresh);
float $dmcs_Adapt = `getAttr vraySettings.dmcs_adaptiveAmount`;
string $dmcs_AdaptMEL = ("setAttr vraySettings.dmcs_adaptiveAmount " + $dmcs_Adapt);
float $dmcs_adaptiveThreshold = `getAttr vraySettings.dmcs_adaptiveThreshold`;
string $dmcs_adaptiveThresholdMEL = ("setAttr vraySettings.dmcs_adaptiveThreshold " + $dmcs_adaptiveThreshold);
int $dmcMaxSubdivs = `getAttr vraySettings.dmcMaxSubdivs`;
string $dmcMaxSubdivsMEL = ("setAttr vraySettings.dmcMaxSubdivs " + $dmcMaxSubdivs);
int $dmcMinSubdivs = `getAttr vraySettings.dmcMinSubdivs`;
string $dmcMinSubdivsMEL = ("setAttr vraySettings.dmcMinSubdivs " + $dmcMinSubdivs);
int $imap_currentPreset = `getAttr vraySettings.imap_currentPreset`;
string $imap_currentPresetMEL = ("setAttr vraySettings.imap_currentPreset " + $imap_currentPreset);
//prompt to save first
string $resulert = `confirmDialog -title "Confirm" -message "Save file first?" 
     -button "Yes" -button "No" -defaultButton "Yes" 
     -cancelButton "No" -dismissString "No"`;

if ($resulert == "Yes") 
	{
	file -f -save;
	}
////Make absolute path to cl app for people without PATH variable set up:
if ( `about -mac` )
	{
	 $pathToRenderer = (("/Applications/Autodesk/maya" + $version + "/Maya.app/Contents/MacOS/") + "Render");
	}
	else if ( `about -linux64` )
	{
	system (("/usr/autodesk/maya") + $version + ("-x64/bin/Render"));
	}
	else if ( `about -win` )
	{
	 $pathToRenderer =  ("\"C\:\\Program\ Files\\Autodesk\\Maya" + $version + ("\\bin\\Render.exe") + "\"");
	}

if ( $resmenuSelection == "10%")
		$renderPercent = 2;
	else if ( $resmenuSelection == "25%")
		$renderPercent = 3;
	else if ( $resmenuSelection == "50%")
		$renderPercent = 4;
	else if ( $resmenuSelection == "75%")
		$renderPercent = 5;
	else if ( $resmenuSelection == "100%")
		$renderPercent = 1;
	else if ( $resmenuSelection == "110%")
		$renderPercent = 6;
	else if ( $resmenuSelection == "125%")
		$renderPercent = 7;
	else if ( $resmenuSelection == "150%")
		$renderPercent = 8;

if ( $renderPercent == 2 )
		$renderPrintFactor = 0.10;
	else if ( $renderPercent == 3)
		$renderPrintFactor = 0.25;
	else if ( $renderPercent == 4)
		$renderPrintFactor = 0.5;
	else if ( $renderPercent == 5)
		$renderPrintFactor = 0.75;
	else if ( $renderPercent == 1)
		$renderPrintFactor = 1.0;	
	else if ( $renderPercent == 6)
		$renderPrintFactor = 1.1;
	else if ( $renderPercent == 7)
		$renderPrintFactor = 1.25;
	else if ( $renderPercent == 8)
		$renderPrintFactor = 1.5;

$finalRenderWidth = ($fullResWidth * $renderPrintFactor);
$finalRenderHeight = ($fullResHeight * $renderPrintFactor);
string $renderContents;
string $version = `getApplicationVersionAsFloat`;
string $startFramer = "";
string $endFramer = "";
string $byFramer = "";
string $catenatedRenderParms = "";

if (`getAttr "defaultRenderGlobals.animation"`)
	{
	$startFramer = ("-s " + `getAttr defaultRenderGlobals.startFrame`);
	$endFramer = (" -e " + `getAttr defaultRenderGlobals.endFrame`);
	$byFramer = (" -b " + `getAttr defaultRenderGlobals.byFrameStep`);
	$catenatedRenderParms = ($startFramer + $endFramer + $byFramer + " ");
	}

//final render contents: 
string $renderContents = ($pathToRenderer + " -r vray " + $catenatedRenderParms + " -preRender \"" + $imap_currentPresetMEL + "\" -preRender \"" + $dmcMinSubdivsMEL + "\" -preRender \"" + $dmcMaxSubdivsMEL + "\" -preRender \"" + $dmcThreshMEL + "\" -preRender \"" + $dmcs_AdaptMEL +  "\" -preRender \"" + $dmcs_adaptiveThresholdMEL + "\" -threads " + $threadCounter + " -x " + $finalRenderWidth + " -y " + $finalRenderHeight + " -proj \"" + $projectDir + "\" \"" + $currentScenePath + "\"\n");

//write the render script
string $exampleFileName = "";
string $basedir = `workspace -q -rd`;
if( `about -win`)
	{
	$exampleFileName = ("C:\\vrayTempRenderer.bat"); 
	}
else if( `about -mac`)
	{
	$exampleFileName = ("/tmp/vrayTempRenderer.command");
	}
else if( `about -linux64`)
	{
	$exampleFileName = ("/tmp/vrayTempRenderer.sh");
	}

$fileId=`fopen $exampleFileName "w"`;
fprint $fileId $renderContents;
fclose $fileId;

if( `about -mac`)
	{
	system ("echo growlnotify -n \"Maya Render\" -I /Applications/Autodesk/maya" + $version + "/Maya.app -m Maya Render Done! >> /tmp/vrayTempRenderer.command");
	system ("chmod +x /tmp/vrayTempRenderer.command");
	}
	else if( `about -linux64`)
	{
	system ("chmod +x /tmp/vrayTempRenderer.sh");
	}
}

global proc renameWithFilename()
{
string $mySelection[] = `ls -sl -exactType "file"`;

//add detection for degamma here 

for($n=0 ; $n<size($mySelection) ; $n++)
	{
	string $filename = `getAttr ($mySelection[$n] + ".ftn")`;
	string $buffer[];
	$numTokens = `tokenize $filename "/" $buffer`;
	int $filenameMaxNum = `size($buffer)`;
	string $nameBuffer[];
	$numTokensToo = `tokenize $buffer[($filenameMaxNum - 1)] "." $nameBuffer`;
	rename $mySelection[$n] $nameBuffer[0];
	}

}

global proc renameWithFilenameVray()
{
string $mySelection[] = `ls -sl -exactType "VRayMtl"`;
//add detection for degamma here
for($n=0 ; $n<size($mySelection) ; $n++)
{
	string $fileNode[] = `listConnections -d 0 -s 1 ($mySelection[$n] + ".color")`;
	string $filename = `getAttr ($fileNode[$n] + ".ftn")`;
	string $buffer[];
	$numTokens = `tokenize $filename "/" $buffer`;
	int $filenameMaxNum = `size($buffer)`;
	string $nameBuffer[];
	$numTokensToo = `tokenize $buffer[($filenameMaxNum - 1)] "." $nameBuffer`;
	rename $mySelection[$n] ($nameBuffer[0] + "_VRay");
	}
}

global proc LWFMeTexture()
{

string $typeFiles[] = `ls -sl -type "file"`;

for ($n=0 ; $n<size($typeFiles) ; $n++)
			{
			vray addAttributesFromGroup $typeFiles[$n] vray_file_gamma 1;
			setAttr ($typeFiles[$n] + ".vrayFileGammaEnable") 1;
			select -d $typeFiles[$n];
			}
string $typeNotFiles[] = `ls -sl`;
for ($n=0 ; $n<size($typeNotFiles) ; $n++)
	{
	//add detection for outAlpha

// string $to[] = { "a", "b", "c" };
//  string $from[] = { "d", "e", "f" };
//  appendStringArray($to, $from, 2);
//	// $to == { "a", "b", "c", "d", "e" }

	string $parentMaterialConnect[] = `listConnections -d true -s false -c false -p true -type "VRayMtl" $typeNotFiles[$n]`;
	string $parentSSSMaterialConnect[] = `listConnections -d true -s false -c false -p true -type "VRayFastSSS2" $typeNotFiles[$n]`;
	int $SSScount = `size($parentSSSMaterialConnect)`;
	appendStringArray ($parentMaterialConnect, $parentSSSMaterialConnect, $SSScount);
	string $parentSSSMaterialConnect[] = `listConnections -d true -s false -c false -p true -type "VRayFastSSS2" $typeNotFiles[$n]`;
	int $SSScount = `size($parentSSSMaterialConnect)`;
	appendStringArray ($parentMaterialConnect, $parentSSSMaterialConnect, $SSScount);
	
	if (size($parentMaterialConnect)>0)
		{
		linearizerWithInput($parentMaterialConnect[0]);
		}
	}
}

global proc rtBatchRenderCaller()
{
setAttr -type "string" vraySettings.rtImageReadyMel "rtBatchRender;";
setAttr "vraySettings.vfbOn" 0;
//prompt for time with dialog

float $RTrenderTime = `getAttr "vraySettings.rt_maxRenderTime"`;

	if ($RTrenderTime == 0)
		{
		error "You need to set the V-RayRT max time to something over 0 or it will render each frame indefinitely.";
		}
	else 
		{
		RedoPreviousIPRRender;
		}

//TO DO: reset IPR MEL values
}

global proc rtBatchRenderCallerToQuality()
{
setAttr -type "string" vraySettings.rtImageReadyMel "rtBatchRenderToQuality;";
setAttr "vraySettings.vfbOn" 0;

float $RTrenderTime = `getAttr "vraySettings.rt_maxRenderTime"`;
//
//	if ($RTrenderTime == 0)
//		{
//		error "You need to set the V-RayRT max time to something over 0 or it will render each frame indefinitely.";
//		}
//	else 
//		{
		RedoPreviousIPRRender;
//		}

//TO DO: reset IPR MEL values
}

//this is a cleanup script that checks for duplicate node names and renames any duplicates it finds. 
global proc uniqueNamer()
{
python( "import maya.cmds as cmds\nobjs = [x for x in cmds.ls(shortNames=True) if '|' in x]\nobjs.sort(key=lambda x : x.count('|'))\nobjs.reverse()\ncopy = [x.rpartition('|')[2] for x in objs]\nfor i in range(len(objs)):\n	if cmds.objExists(copy[i]):\n		cmds.rename(objs[i], objs[i].replace('|', ''))\nif not len([x for x in cmds.ls(shortNames=True) if '|' in x]):\n	print ''" );
}

proc saveImage(string $filename) {
string $renderPanels[] = `getPanel -scriptType "renderWindowPanel"`;
  if (size($renderPanels)==0)
      return;
  python("import maya.app.general.createImageFormats as createImageFormats");
  python("formatManager = createImageFormats.ImageFormats()");
  python("formatManager.pushRenderGlobalsForDesc(\"PNG\")");
          renderWindowEditor -e -writeImage $filename $renderPanels;
      python("formatManager.popRenderGlobals()");
}

global proc rtBatchRenderToQuality() 
{
int $frameStamp = `currentTime -q`;
string $projectDir = `workspace -q -rd`;
sysFile -makeDir ($projectDir + "/images/VRayRT_Playblast"); 
string $pad = `python ("'%04d' % "+$frameStamp)`;
int $maxFrame = `getAttr "defaultRenderGlobals.endFrame"`;
  saveImage($projectDir + "/images/VRayRT_Playblast/" + ("IPR_Frame_Render." + $pad));
  if (currentTime("-q")<$maxFrame) currentTime(currentTime("-q")+1);
//DO A CHECK TO SEE IF END FRAME REACHED 
  else if (currentTime("-q")==$maxFrame)
  {
  setAttr -type "string" vraySettings.rtImageReadyMel "";
  warning "RT multi-frame render done.\n";
  }

}

global proc rtBatchRender() {
int $frameStamp = `currentTime -q`;
string $projectDir = `workspace -q -rd`;
sysFile -makeDir ($projectDir + "/images/VRayRT_Playblast"); 
string $pad = `python ("'%04d' % "+$frameStamp)`;
int $maxFrame = `getAttr "defaultRenderGlobals.endFrame"`;
  saveImage($projectDir + "/images/VRayRT_Playblast/" + ("IPR_Frame_Render." + $pad));
  if (currentTime("-q")<$maxFrame) currentTime(currentTime("-q")+1);
//DO A CHECK TO SEE IF END FRAME REACHED 
else if (currentTime("-q")==$maxFrame)
  {
  setAttr -type "string" vraySettings.rtImageReadyMel "";
  }
}

global proc selectGIProblemOBJs()
{
select -cl;
string $myMeshes[] = `ls -exactType "mesh"`;
for ($n=0 ; $n<size($myMeshes) ; $n++)
	{
	int $check = `getAttr ($myMeshes[$n] + ".visibleInReflections")`;
		if( size($myMeshes) > 0 && ($check == 0))
		{
		select -add $myMeshes[$n];
		warning ($myMeshes[$n] + " is not visible in reflections. OBJ import error? Object selected.\n");
		}

	}
}

global proc renderWithCheck()
{
select -cl;
uniqueNamer;
string $myMeshes[] = `ls -exactType "mesh"`;
for ($n=0 ; $n<size($myMeshes) ; $n++)
	{
	int $check = `getAttr ($myMeshes[$n] + ".visibleInReflections")`;
		if( size($myMeshes) > 0 && ($check == 0))
		{
		select -add $myMeshes[$n];
		warning ($myMeshes[$n] + " is not visible in reflections. OBJ import error? Object selected.\n");
		}	
	}
RedoPreviousRender;
}

global proc displaceLocker()
{
string $mySelection[] = `ls -sl`;
string $shapes[] = `listRelatives -s $mySelection[0]`;
string $sGroup[] = `listSets -type 1 -o $shapes[0]`;
string $dNode[] = `listConnections -d 0 -s 1 ($sGroup[0] + ".displacementShader")`;
string $file[] = `listConnections -d 0 -s 1 ($dNode[0] + ".displacement")`;
string $dispMap = $file[0];
float $gainValue = `getAttr ($dispMap + ".alphaGain")`;
float $alphaOffset = `getAttr ($dispMap + ".alphaOffset")`;

expression -string ($dispMap + ".alphaGain = "+$gainValue+" * " + $mySelection[0] + ".scaleX;\n" + $dispMap + ".alphaOffset = "+$alphaOffset+" * " + $mySelection[0] + ".scaleX;") -o $mySelection[0] -ae 1 -uc all;
}


global proc objRenderFix()
{
string $mySelection[] = `ls -sl`;

for($each in $mySelection)
	{
	string $mySelectionShapes[] = `listRelatives -s $each`;
			if( !(nodeType($each) == "mesh") )
			{
			select -cl;
			}
	{
	setAttr ($each + ".visibleInRefractions") 1;
	setAttr ($each + ".visibleInReflections") 1;
	}
	}
select -r $mySelection;
}

global proc materialDropperCopy()
{
string $mySelection[] = `ls -sl -fl`;
string $bufferObj[];
tokenize $mySelection[0] "." $bufferObj;
string $surfaceShaderDup[];

//if whole objects:
if ($bufferObj[1] == "")//just object selected because token buffer is empty
    {
	string $mySelectionShapes[] = `listRelatives -s $mySelection[0]`;
	string $sGroupTempToCopy[] = `listSets -type 1 -o $mySelectionShapes[0]`;
	string $surfaceShader[] = `listConnections ($sGroupTempToCopy[0] + ".surfaceShader")`;
	if ( `size $mySelection` == 1 )
		{
			select -r $surfaceShader[0];
			$surfaceShaderDup = `duplicate -upstreamNodes`;
			select -r $mySelection[0];
			hyperShade -assign $surfaceShaderDup[0] $mySelection[0];
		}

	else 
		{
		for ($n=1 ; $n<size($mySelection) ; $n++)
			{
				select -r $surfaceShader[0];
				$surfaceShaderDup = `duplicate -upstreamNodes`;
				select -r $mySelection[$n];
				hyperShade -assign $surfaceShaderDup[0] $mySelection[$n];
			}
		}
	}
//if components selected:
else if ($bufferObj[1] != "")
    {
    if ( `size $mySelection` == 1 )
		{
			string $shadery = getComponentShader ($mySelection[0]);
			select -r $shadery;
			$surfaceShaderDup = `duplicate -upstreamNodes`;
			select -r $mySelection[0];
			hyperShade -assign $surfaceShaderDup[0] $mySelection[0];
		}

	else 
		{
		string $shadery = getComponentShader ($mySelection[0]); 
		for ($n=1 ; $n<size($mySelection) ; $n++)
			{
				string $shadery = getComponentShader ($mySelection[0]);
				select -r $shadery;
				$surfaceShaderDup = `duplicate -upstreamNodes`;
				select -r $mySelection[$n];
				hyperShade -assign $surfaceShaderDup $mySelection[$n];
				//select -r $surfaceShader[0];
			
				//hyperShade -assign $surfaceShaderDup[0] $mySelection[$n];
			}
		}
    }
}

global proc materialDropper()
{
string $mySelection[] = `ls -sl -fl`;
string $bufferObj[];
tokenize $mySelection[0] "." $bufferObj;
if ($bufferObj[1] == "")//just object selected because token buffer is empty
    {
	string $mySelectionShapes[] = `listRelatives -s $mySelection[0]`;
	string $sGroupTempToCopy[] = `listSets -type 1 -o $mySelectionShapes[0]`;
	string $surfaceShader[] = `listConnections ($sGroupTempToCopy[0] + ".surfaceShader")`;

	for ($n=1 ; $n<size($mySelection) ; $n++)
		{
		select -r $mySelection[$n];
		hyperShade -assign $surfaceShader[0] $mySelection[$n];
		}
	}
else if ($bufferObj[1] != "")
    {
    for ($n=1 ; $n<size($mySelection) ; $n++)
		{
		string $shadery = getComponentShader ($mySelection[0]); 
		hyperShade -assign $shadery $mySelection[$n];
		}
    }
}

global proc vray15MatConverter()
{
string $mySelection[] = `ls -sl`;
float $myDiffuse[] = `getAttr ($mySelection[0] + ".diffuseColor")`;
float $myDiffuseMax[] = {($myDiffuse[0] * 255), ($myDiffuse[1] * 255), ($myDiffuse[2] * 255)};
float $myRoughness = `getAttr ($mySelection[0] + ".roughnessAmount")`;
float $myreflectionColor[] = `getAttr ($mySelection[0] + ".reflectionColor")`;
float $myreflectionColorMax[] = {($myreflectionColor[0] * 255), ($myreflectionColor[1] * 255), ($myreflectionColor[2] * 255)};
float $myfresnelIOR = `getAttr ($mySelection[0] + ".fresnelIOR")`;
float $myrefractionIOR = `getAttr ($mySelection[0] + ".refractionIOR")`;
float $myreflectionGlossiness = `getAttr ($mySelection[0] + ".reflectionGlossiness")`;
int $myreflectionSubdivs = `getAttr ($mySelection[0] + ".reflectionSubdivs")`;
int $myuseFresnel = `getAttr ($mySelection[0] + ".useFresnel")`;
string $booluseFresnel = ($myuseFresnel == 0) ? "false" : "true";
int $myreflectionsMaxDepth = `getAttr ($mySelection[0] + ".reflectionsMaxDepth")`;
float $myreflectionExitColor[] = `getAttr ($mySelection[0] + ".reflectionExitColor")`;
float $myreflectionExitColorMax[] = {($myreflectionExitColor[0] * 255), ($myreflectionExitColor[1] * 255), ($myreflectionExitColor[2] * 255)};
int $myreflInterpolation = `getAttr ($mySelection[0] + ".reflInterpolation")`;
string $boolmyreflInterpolation = ($myreflInterpolation == 0) ? "false" : "true";
int $myrefrInterpolation = `getAttr ($mySelection[0] + ".refrInterpolation")`;
string $boolmyrefrInterpolation = ($myrefrInterpolation == 0) ? "false" : "true";
int $myhilightGlossinessLock = `getAttr ($mySelection[0] + ".hilightGlossinessLock")`;
string $boolhilightGlossinessLock = ($myhilightGlossinessLock == 0) ? "false" : "true";
int $mylockFresnelIORToRefractionIOR = `getAttr ($mySelection[0] + ".lockFresnelIORToRefractionIOR")`;
string $boolmylockFresnelIORToRefractionIOR = ($mylockFresnelIORToRefractionIOR == 0) ? "false" : "true";
float $myrefractionColor[] = `getAttr ($mySelection[0] + ".refractionColor")`;
float $myrefractionColorMax[] = {($myrefractionColor[0] * 255), ($myrefractionColor[1] * 255), ($myrefractionColor[2] * 255)};
float $myrefractionGlossiness = `getAttr ($mySelection[0] + ".refractionGlossiness")`;
int $myrefractionSubdivs = `getAttr ($mySelection[0] + ".refractionSubdivs")`;
float $myfogColor[] = `getAttr ($mySelection[0] + ".fogColor")`;
float $myfogColorMax[] = {($myfogColor[0] * 255), ($myfogColor[1] * 255), ($myfogColor[2] * 255)};
float $myfogMult = `getAttr ($mySelection[0] + ".fogMult")`;
float $myfogBias = `getAttr ($mySelection[0] + ".fogBias")`;
int $myaffectShadows = `getAttr ($mySelection[0] + ".affectShadows")`;
string $boolmyaffectShadows = ($myaffectShadows == 0) ? "false" : "true";
int $myaffectAlpha = `getAttr ($mySelection[0] + ".affectAlpha")`;
string $boolmyaffectAlpha = ($myaffectAlpha == 0) ? "false" : "true";
int $myrefractionsMaxDepth = `getAttr ($mySelection[0] + ".refractionsMaxDepth")`;
float $myrefractionExitColor[] = `getAttr ($mySelection[0] + ".refractionExitColor")`;
float $myrefractionExitColorMax[] = {($myrefractionExitColor[0] * 255), ($myrefractionExitColor[1] * 255), ($myrefractionExitColor[2] * 255)};
int $myrefractionExitColorOn = `getAttr ($mySelection[0] + ".refractionExitColorOn")`;
string $boolmyrefractionExitColorOn = ($myrefractionExitColorOn == 0) ? "false" : "true";
float $myscatterCoeff = `getAttr ($mySelection[0] + ".scatterCoeff")`;
float $myscatterDir = `getAttr ($mySelection[0] + ".scatterDir")`;
float $mytranslucencyColor[] = `getAttr ($mySelection[0] + ".translucencyColor")`;
float $mytranslucencyColorMax[] = {($mytranslucencyColor[0] * 255), ($mytranslucencyColor[1] * 255), ($mytranslucencyColor[2] * 255)};
int $mybrdfType = `getAttr ($mySelection[0] + ".brdfType")`;
float $myanisotropy = `getAttr ($mySelection[0] + ".anisotropy")`;
float $myanisotropyRotation = `getAttr ($mySelection[0] + ".anisotropyRotation")`;
float $mysoftenEdge = `getAttr ($mySelection[0] + ".softenEdge")`;
int $mytraceReflections = `getAttr ($mySelection[0] + ".traceReflections")`;
string $boolmytraceReflections = ($mytraceReflections == 0) ? "false" : "true";
int $mytraceRefractions = `getAttr ($mySelection[0] + ".traceRefractions")`;
string $boolmytraceRefractions = ($mytraceRefractions == 0) ? "false" : "true";
int $myreflectOnBackSide = `getAttr ($mySelection[0] + ".reflectOnBackSide")`;
string $boolmyreflectOnBackSide = ($myreflectOnBackSide == 0) ? "false" : "true";
int $myuseIrradianceMap = `getAttr ($mySelection[0] + ".useIrradianceMap")`;
string $boolmyuseIrradianceMap = ($myuseIrradianceMap == 0) ? "false" : "true";
float $mybumpMult = `getAttr ($mySelection[0] + ".bumpMult")`;

string $maxScriptTemplate = "objs = selectByName title:\"Select the objects you want to create a VRay material for\"\n\
for obj in objs do \(\n\
newMat = VRayMtl\(\)\n\
newMat.diffuse = [" + $myDiffuseMax[0] + "," + $myDiffuseMax[1] + "," + $myDiffuseMax[2] + "]\n\
newMat.diffuse_roughness = " + $myRoughness + "\n\
newMat.reflection = [" + $myreflectionColorMax[0] + "," + $myreflectionColorMax[1] + "," + $myreflectionColorMax[2] + "]\n\
newMat.reflection_glossiness = " + $myreflectionGlossiness + "\n\
newMat.reflection_subdivs = " + $myreflectionSubdivs + "\n\
newMat.reflection_fresnel = " + $booluseFresnel + " \n\
newMat.reflection_maxDepth = " + $myreflectionsMaxDepth + "\n\
newMat.reflection_exitColor = [" + $myreflectionExitColorMax[0] + "," + $myreflectionExitColorMax[1] + "," + $myreflectionExitColorMax[2] + "]\n\
newMat.reflection_useInterpolation = " + $boolmyreflInterpolation + "\n\
newMat.reflection_lockGlossiness = " + $boolhilightGlossinessLock + "\n\
newMat.hilight_glossiness = " + $myreflectionGlossiness + "\n\
newMat.reflection_ior = " + $myfresnelIOR + "\n\
newMat.reflection_lockIOR = " + $boolmylockFresnelIORToRefractionIOR + "\n\
newMat.refraction = [" + $myrefractionColorMax[0] + "," + $myrefractionColorMax[1] + "," + $myrefractionColorMax[2] + "]\n\
newMat.refraction_glossiness = " + $myrefractionGlossiness + "\n\
newMat.refraction_subdivs = " + $myrefractionSubdivs + "\n\
newMat.refraction_ior = " + $myrefractionIOR + "\n\
newMat.refraction_fogColor = [" + $myfogColorMax[0] + "," + $myfogColorMax[1] + "," + $myfogColorMax[2] + "]\n\
newMat.refraction_fogMult = " + $myfogMult + "\n\
newMat.refraction_fogBias = " + $myfogBias + "\n\
newMat.refraction_affectShadows = " + $boolmyaffectShadows + "\n\
newMat.refraction_affectAlpha = " + $myaffectAlpha + "\n\
newMat.refraction_maxDepth = " + $myrefractionsMaxDepth + "\n\
newMat.refraction_exitColor = [" + $myrefractionExitColorMax[0] + "," + $myrefractionExitColorMax[1] + "," + $myrefractionExitColorMax[2] + "]\n\
newMat.refraction_useExitColor = " + $boolmyrefractionExitColorOn + "\n\
newMat.refraction_useInterpolation = " + $boolmyrefrInterpolation + "\n\
newMat.translucency_scatterCoeff = " + $myscatterCoeff + "\n\
newMat.translucency_fbCoeff = " + $myscatterDir + "\n\
newMat.translucency_color = [" + $mytranslucencyColorMax[0] + "," + $mytranslucencyColorMax[1] + "," + $mytranslucencyColorMax[2] + "]\n\
newMat.brdf_type = " + $mybrdfType + "\n\
newMat.anisotropy = " + $myanisotropy + "\n\
newMat.anisotropy_rotation = " + $myanisotropyRotation + "\n\
newMat.soften = " + $mysoftenEdge + "\n\
newMat.option_traceReflection = " + $boolmytraceReflections + "\n\
newMat.option_traceRefraction = " + $boolmytraceRefractions + "\n\
newMat.option_reflectOnBack = " + $boolmyreflectOnBackSide + "\n\
newMat.option_useIrradMap = " + $boolmyuseIrradianceMap + "\n\
newMat.texmap_bump_multiplier = " + $mybumpMult + "\n\
obj.material = newMat  \n\
\)\n";

string $singleFilter = "Text Files (*.txt)";
string $resultNamey[] = `fileDialog2 -fileFilter $singleFilter`;
$exampleFileName = $resultNamey[0];
$fileId=`fopen $exampleFileName "w"`;
fprint $fileId $maxScriptTemplate;
fclose $fileId;

if( `about -win`)
	{
	system $resultNamey[0]; 
	}
else if ( `about -mac`)
	{
	system ("open -a /Applications/TextEdit.app " + $resultNamey[0]);
	//Dave's personal setting
	//system ("cat " + $resultNamey[0] + " | pbcopy");
	}
}
//END VRay 1.5 MaxScript converter 

global proc rtEvalGPUMode()
{
$currentVRayVal = !(`getAttr vraySettings.rt_engineType`);
setAttr vraySettings.rt_engineType $currentVRayVal;
}

global proc rtEvalDisplacement()
{
$currentVRayVal = !(`getAttr vraySettings.rt_displacement`);
setAttr vraySettings.rt_displacement $currentVRayVal;
}

global proc rtEvalProxies()
{
$currentVRayVal = !(`getAttr vraySettings.rt_vrayProxyObjects`);
setAttr vraySettings.rt_vrayProxyObjects $currentVRayVal;
}

global proc rtEvalSubdivision()
{
$currentVRayVal = !(`getAttr vraySettings.rt_subdivision`);
setAttr vraySettings.rt_subdivision $currentVRayVal;
}

global proc rtEvalHair()
{
$currentVRayVal = !(`getAttr vraySettings.rt_hair`);
setAttr vraySettings.rt_hair $currentVRayVal;
}

global proc rtEvalFur()
{
$currentVRayVal = !(`getAttr vraySettings.rt_fur`);
setAttr vraySettings.rt_fur $currentVRayVal;
}

global proc rtEvalParticles()
{
$currentVRayVal = !(`getAttr vraySettings.rt_particleSystems`);
setAttr vraySettings.rt_particleSystems $currentVRayVal;
}

global proc vrayPassesToNuke()
{
python "import vrayToNuke; vrayToNuke.DB_vraytonuke()";
warning "Requires Deex V-Ray To Nuke: http://deex.info";
}


global proc lwfMe()
{
setAttr vraySettings.cmap_linearworkflow 1;
setAttr vraySettings.cmap_adaptationOnly 1;
setAttr vraySettings.giOn 1;
setAttr vraySettings.cmap_gamma 2.2;
setAttr vraySettings.sRGBOn 1;
//Dave's personal settings 
//setAttr "vraySettings.cmap_affectBackground" 1;
//setAttr "vraySettings.imageFormatStr" -type "string" "exr";
//end Dave's personal settings 

warning "The Maya Render view is now corrected for Linear Workflow. Enable sRGB in the VFB to see it properly there too.";
}

global proc targetCard()
{
string $mySelection[] = `ls -sl`;
//string $mySelection1Shape[] = `listRelatives -s $mySelection[0]`;
string $card[] = `polyPlane -w 100 -h 100 -sx 1 -sy 1 -ax 0 1 0 -cuv 2 -ch 1`;
string $mySelectionShapes[] = `listRelatives -s`;
select -af $mySelection[0];
aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 1 1 0 -worldUpType "vector" -worldUpVector 0 1 0;
select -r $card[0];
move -r 20 20 -20;
setAttr ($mySelectionShapes[0] + ".primaryVisibility") 0 ;
setAttr ($mySelectionShapes[0] + ".castsShadows") 0;
setAttr ($mySelectionShapes[0] + ".receiveShadows") 0;
}

global proc targetLight()
{
string $mySelection[] = `ls -sl`;
string $mySelection[] = `ls -sl`;
string $mySelection1Shape[] = `listRelatives -s $mySelection[0]`;
string $check[] = `ls -exactType "VRayLightRectShape" $mySelection1Shape[0]`;
int $checker = `gmatch $check[0] "VRayLightRectShape*"`;

	if ($checker == 1)
	{ 
	select -d $mySelection[1];
	select -af $mySelection[1];
	}
aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0;
}


// maya2VRay.mel 
// Version 1.0
// by Paul Dreisen paul@dryzen.com
/*	
Usage:

	This script converts the most used shaders from Maya and Maya + MR (Mia material) into a VRay Material.
	The scripts scans the most common used inputs of your shader and connects them to a new VRay shader.
	After all the connections are made it connects the VRay shader into the shading group of the old material, so it will work with renderpass assignements etc.
	
Limitations:
	
!!!	If you want to convert a mia shader you must first use the upgrade feature of Maya to convert it into a mia_material_passes_x!!!

	Due to the fact that some inputs (incandescence; ambientColor and some more) are not present in the VRay material, those connections are going to be lost.
	Complex shading networks with multiple shaders cannot be converted with this script. Those networks need to be converted one shader at a time!
	It is not possible to convert/connect the inputs that they look completely the same with the VRay shader, but the look will go in the right direction.

How to:

	1. select any Mia material you want. If it is an old material like MiaX, Mia, or Mia_material_pass use the upgrade feature in the attribute Editor.
	2. upgrade the material into a "mia_material_x_passes" (you can find the upgrade button insde the attribute editor)
 	3. run the script. The script works with any number of shaders, but I suggest to do it only with one at a time ;-)
	4. If you are converting normal Maya shader, there is no need to change everything. Right now the script converts only Blinn, Lamber and Phong shaders!

Version:
		1.0	First version of the script. It can convert Lambert, Blinn, Phong and Mia_material_pass_x tinto a VRay material.	
I hope the script will save you some time on the scene conversion. If there is any problem or something you would like to have, please contact me!
Thanks Paul
*/

global proc maya2VRay()
{
	// get selected shaders
		string $sel[] = `ls -sl -st`;
		for ($i=0;$i<size($sel);$i=$i+2)
	{
		// $i=$i+2 takes every second string and runs the script
		// $sel[$i]=object
		// $sel[$i+1]=objectType
		

	if ($sel[$i+1] == "lambert")
		{	
			print ("\n");
			print ("running Lambert conversion on " + $sel[$i] + " hold on tight");
			lambert2VRay($sel[$i]);
		}

	else if ($sel[$i+1] == "blinn")
		{		
			print ("\n");
			print ("running Blinn conversion on " + $sel[$i] + " hold on tight");
			blinn2VRay($sel[$i]);
		}
	else if ($sel[$i+1] == "phong")
		{	
			print ("\n");
			print ("running Phong conversion on " + $sel[$i] + " hold on tight");
			phong2VRay($sel[$i]);
		}
	else if ($sel[$i+1] == "mia_material_x_passes")
		{	
			print ("\n");
			print ("running Mia conversion on " + $sel[$i] + " hold on tight");
			mia2VRay($sel[$i]);
		}
	}	
}

// now the sub scripts for the different shading networks.

	global proc lambert2VRay(string $obj)
{

		// first create a new VRay material

	$newMtl=`shadingNode -as -n ($obj +"_VRAY") VRayMtl`;
		
		// use this string to fill up all the needed connections. It works like this 1. Value = the input of the source shader like lambert.diffuse
		// and the second value is the input of the ne VRay material like VRayMat1.diffuseColor
		// You can easily add new connections if you need them, just add them at the end of the next string $conMap[], but allways use 2 values
	// note: You will need 2 arrays: one for alle connections with 3 RGB inputs and the second array with all the alpha or single value inputs
		// start with the ones with 3 inputs!!
		
		string $conMap[] = {".color", ".diffuseColor"};
		string $conMapSingle[] = {".diffuse", ".diffuseColorAmount"};
		
		for ($i=0;$i<size($conMap);$i=$i+2)
	{
	
		string $conn=`connectionInfo -sfd ($obj + $conMap[$i])`;

	if ($conn=="")
		{
			float $temporary[]=`getAttr ($obj + $conMap[$i])`;
			setAttr ($newMtl+$conMap[$i+1]) -type double3 $temporary[0] $temporary[1] $temporary[2];
		}
	else
		{
		connectAttr -f $conn ($newMtl + $conMap[$i+1]);
		}
	}
		
		for ($i=0;$i<size($conMapSingle);$i=$i+2)
	
	{
		string $connSingle=`connectionInfo -sfd ($obj + $conMapSingle[$i])`;
		print $connSingle;
	if ($connSingle=="")
		{
			float $temporary=`getAttr ($obj + $conMapSingle[$i])`;
			setAttr ($newMtl + $conMapSingle[$i+1]) $temporary;
		}
	else
		{
			connectAttr -f $connSingle ($newMtl + $conMapSingle[$i+1]);
		}

	}
// next step the bump connection, wasn¥t possible to do it with the other connections

	string $bump[] = `listConnections -d off -s on ($obj +".normalCamera")`;	

		if ($bump[0]=="")
			{
				print ("\n");	print "no bump connected";print ("\n");

			}
		else
			{
				string $bumpcon=`connectionInfo -sfd ($bump[0] +".bumpValue")`;
				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapR");
				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapG");
				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapB");
				float $bumpdepth=`getAttr ($bump[0]+".bumpDepth")`;
				setAttr ($newMtl+".bumpMult") $bumpdepth;
			}
	// get the connection of the transparency of the Maya shader

	string $trans = `connectionInfo -sfd ($obj +".transparency")`;	

		if ($trans=="")
			{
				// if there is only a value it needs to be reversed!!! this will work good with no colors here, but could lead to strange results with colored transparency values!!!
				float $temporary[]=`getAttr ($obj + ".transparency")`;
				float $temporaryR = $temporary[0] * -1 +1;
				float $temporaryG = $temporary[1] * -1 +1;
				float $temporaryB = $temporary[2] * -1 +1;
				setAttr ($newMtl + ".opacityMap") -type double3 $temporaryR $temporaryG $temporaryB;
				
				
			}
		else
			{
				// if there is a connected texture we need a reverse node to make the transparency work with the VRay shader, it has the same problem with colored transparency, but hopefully it will work a bit.
				$reverse=`shadingNode -au -n ($obj +"REVERSE") reverse`;
				connectAttr -f $trans ($reverse +".input");
				connectAttr -f ($reverse + ".output") ($newMtl +".opacityMap");

			}

// find the shading group and connect the new VRay shader

	string $SG[] = `listConnections -t shadingEngine $obj`;
	connectAttr -f ($newMtl +".outColor") ($SG[0] +".surfaceShader");
// delete the original shader

	delete $obj;
}

global proc blinn2VRay(string $obj)
{

		// first create a new VRay material

	$newMtl=`shadingNode -as -n ($obj +"_VRAY") VRayMtl`;
		
		// use this string to fill up all the needed connections. It works like this 1. Value = the inpuet of the source shader like lambert.diffuse
		// and the second value is the input of the ne VRay material like VRayMat1.diffuseColor
		// You can easily add new connections if you need them, just add them at the end of the next string $conMap[], but allways use 2 values
	// note: You will need 2 arrays: one for alle connections with 3 RGB inputs and the second array with all the alpha or single value inputs
		// start with the ones with 3 inputs!!
				
		string $conMap[] = 	{	".color", ".diffuseColor",
						".reflectedColor", ".reflectionColor",
						".specularColor", ".reflectionColor" 
					};
		string $conMapSingle[] = 	{	".diffuse", ".diffuseColorAmount",
							".reflectivity", ".reflectionColorAmount",
							".eccentricity", ".reflectionGlossiness"
						};
		
		for ($i=0;$i<size($conMap);$i=$i+2)
	{
	
		string $conn=`connectionInfo -sfd ($obj + $conMap[$i])`;

	if ($conn=="")
		{
			float $temporary[]=`getAttr ($obj + $conMap[$i])`;
			setAttr ($newMtl+$conMap[$i+1]) -type double3 $temporary[0] $temporary[1] $temporary[2];
		}
	else
		{
		connectAttr -f $conn ($newMtl + $conMap[$i+1]);
		}
	}
		
		for ($i=0;$i<size($conMapSingle);$i=$i+2)
	
	{
		string $connSingle=`connectionInfo -sfd ($obj + $conMapSingle[$i])`;
		print $connSingle;
	if ($connSingle=="")
		{
			float $temporary=`getAttr ($obj + $conMapSingle[$i])`;
			setAttr ($newMtl + $conMapSingle[$i+1]) $temporary;
		}
	else
		{
			connectAttr -f $connSingle ($newMtl + $conMapSingle[$i+1]);
		}

	}
// next step the bump connection, wasn¥t possible to do it with the other connections

	string $bump[] = `listConnections -d off -s on ($obj +".normalCamera")`;	

		if ($bump[0]=="")
			{
				print ("\n");	print "no bump connected";print ("\n");

			}
		else
			{
				string $bumpcon=`connectionInfo -sfd ($bump[0] +".bumpValue")`;
				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapR");
				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapG");
				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapB");
				float $bumpdepth=`getAttr ($bump[0]+".bumpDepth")`;
				setAttr ($newMtl+".bumpMult") $bumpdepth;
			}
	// get the connection of the transparency of the Maya shader

	string $trans = `connectionInfo -sfd ($obj +".transparency")`;	

		if ($trans=="")
			{
				// if there is only a value it needs to be reversed!!! this will work good with no colors here, but could lead to strange results with colored transparency values!!!
				float $temporary[]=`getAttr ($obj + ".transparency")`;
				float $temporaryR = $temporary[0] * -1 +1;
				float $temporaryG = $temporary[1] * -1 +1;
				float $temporaryB = $temporary[2] * -1 +1;
				setAttr ($newMtl + ".opacityMap") -type double3 $temporaryR $temporaryG $temporaryB;
				
				
			}
		else
			{
				// if there is a connected texture we need a reverse node to make the transparency work with the VRay shader, it has the same problem with colored transparency, but hopefully it will work a bit.
				$reverse=`shadingNode -au -n ($obj +"REVERSE") reverse`;
				connectAttr -f $trans ($reverse +".input");
				connectAttr -f ($reverse + ".output") ($newMtl +".opacityMap");

			}
// some basic settings for the new shader to match the look of the Maya blinn

setAttr ($newMtl+".useFresnel") 1;

// find the shading group and connect the new VRay shader

	string $SG[] = `listConnections -t shadingEngine $obj`;
	connectAttr -f ($newMtl +".outColor") ($SG[0] +".surfaceShader");
// delete the original shader

	delete $obj;
}

global proc phong2VRay(string $obj)
{

		// first create a new VRay material

	$newMtl=`shadingNode -as -n ($obj +"_VRAY") VRayMtl`;
		
		// use this string to fill up all the needed connections. It works like this 1. Value = the inpuet of the source shader like lambert.diffuse
		// and the second value is the input of the ne VRay material like VRayMat1.diffuseColor
		// You can easily add new connections if you need them, just add them at the end of the next string $conMap[], but allways use 2 values
	// note: You will need 2 arrays: one for alle connections with 3 RGB inputs and the second array with all the alpha or single value inputs
		// start with the ones with 3 inputs!!
				
		string $conMap[] = 	{	".color", ".diffuseColor",
						".reflectedColor", ".reflectionColor",
						".specularColor", ".reflectionColor" 
					};
		string $conMapSingle[] = 	{	".diffuse", ".diffuseColorAmount",
							".reflectivity", ".reflectionColorAmount"
						};
		
		for ($i=0;$i<size($conMap);$i=$i+2)
	{
	
		string $conn=`connectionInfo -sfd ($obj + $conMap[$i])`;

	if ($conn=="")
		{
			float $temporary[]=`getAttr ($obj + $conMap[$i])`;
			setAttr ($newMtl+$conMap[$i+1]) -type double3 $temporary[0] $temporary[1] $temporary[2];
		}
	else
		{
		connectAttr -f $conn ($newMtl + $conMap[$i+1]);
		}
	}
		
		for ($i=0;$i<size($conMapSingle);$i=$i+2)
	
	{
		string $connSingle=`connectionInfo -sfd ($obj + $conMapSingle[$i])`;
		print $connSingle;
	if ($connSingle=="")
		{
			float $temporary=`getAttr ($obj + $conMapSingle[$i])`;
			setAttr ($newMtl + $conMapSingle[$i+1]) $temporary;
		}
	else
		{
			connectAttr -f $connSingle ($newMtl + $conMapSingle[$i+1]);
		}

	}
// next step the bump connection, wasn¥t possible to do it with the other connections

	string $bump[] = `listConnections -d off -s on ($obj +".normalCamera")`;	

		if ($bump[0]=="")
			{
				print ("\n");	print "no bump connected";print ("\n");

			}
		else
			{
				string $bumpcon=`connectionInfo -sfd ($bump[0] +".bumpValue")`;
				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapR");
				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapG");
				connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapB");
				float $bumpdepth=`getAttr ($bump[0]+".bumpDepth")`;
				setAttr ($newMtl+".bumpMult") $bumpdepth;
			}
	// get the connection of the transparency of the Maya shader

	string $trans = `connectionInfo -sfd ($obj +".transparency")`;	

		if ($trans=="")
			{
				// if there is only a value it needs to be reversed!!! this will work good with no colors here, but could lead to strange results with colored transparency values!!!
				float $temporary[]=`getAttr ($obj + ".transparency")`;
				float $temporaryR = $temporary[0] * -1 +1;
				float $temporaryG = $temporary[1] * -1 +1;
				float $temporaryB = $temporary[2] * -1 +1;
				setAttr ($newMtl + ".opacityMap") -type double3 $temporaryR $temporaryG $temporaryB;
				
				
			}
		else
			{
				// if there is a connected texture we need a reverse node to make the transparency work with the VRay shader, it has the same problem with colored transparency, but hopefully it will work a bit.
				$reverse=`shadingNode -au -n ($obj +"REVERSE") reverse`;
				connectAttr -f $trans ($reverse +".input");
				connectAttr -f ($reverse + ".output") ($newMtl +".opacityMap");

			}
// get the cosingePower of the phong shader and convert the value to match the VRay shader values


			float $cosPower=`getAttr ($obj + ".cosinePower")`;
			setAttr ($newMtl + ".reflectionGlossiness") ($cosPower / 100);


// some basic settings for the new shader to match the look of the Maya blinn

setAttr ($newMtl+".useFresnel") 1;
setAttr ($newMtl+".brdfType") 0;

// find the shading group and connect the new VRay shader

	string $SG[] = `listConnections -t shadingEngine $obj`;
	connectAttr -f ($newMtl +".outColor") ($SG[0] +".surfaceShader");
// delete the original shader

	delete $obj;
}

global proc mia2VRay(string $obj)
{

		// first create a new VRay material

			$newMtl=`shadingNode -as -n ($obj +"_VRAY") VRayMtl`;
		
		// use this string to fill up all the needed connections. It works like this 1. Value = the inpuet of the source shader like lambert.diffuse
		// and the second value is the input of the ne VRay material like VRayMat1.diffuseColor
		// You can easily add new connections if you need them, just add them at the end of the next string $conMap[], but allways use 2 values
		// note: You will need 2 arrays: one for alle connections with 3 RGB inputs and the second array with all the alpha or single value inputs
		// start with the ones with 3 inputs!!
		
		string $conMap[] = {	".diffuse", ".diffuseColor", 
					".refl_color", ".reflectionColor",
					".refr_color", ".refractionColor", 
					".refr_falloff_color", ".fogColor" };

		// single value link connections source first, then input

		string $conMapSingle[] = {	".diffuse_weight", ".diffuseColorAmount", 
						".diffuse_roughness", ".roughnessAmount", 
						".reflectivity", ".reflectionColorAmount", 
						".refl_gloss", ".reflectionGlossiness", 
						".transparency", ".refractionColorAmount", 
						".refr_ior", ".refractionIOR", 
						".refr_gloss", ".refractionGlossiness"};
		
		for ($i=0;$i<size($conMap);$i=$i+2)
	{
	
		string $conn=`connectionInfo -sfd ($obj + $conMap[$i])`;

	if ($conn=="")
		{
			float $temporary[]=`getAttr ($obj + $conMap[$i])`;
			setAttr ($newMtl+$conMap[$i+1]) -type double3 $temporary[0] $temporary[1] $temporary[2];
		}
	else
		{
		connectAttr -f $conn ($newMtl + $conMap[$i+1]);
		}
	}
		
		for ($i=0;$i<size($conMapSingle);$i=$i+2)
	
	{
		string $connSingle=`connectionInfo -sfd ($obj + $conMapSingle[$i])`;
		print $connSingle;
	if ($connSingle=="")
		{
			float $temporary=`getAttr ($obj + $conMapSingle[$i])`;
			setAttr ($newMtl + $conMapSingle[$i+1]) $temporary;
		}
	else
		{
			connectAttr -f $connSingle ($newMtl + $conMapSingle[$i+1]);
		}

}

// get the bump connection for the overal bump slot

	string $bump[] = `listConnections -d off -s on ($obj +".overall_bump")`;
	string $bump1[] = `listConnections -d off -s on ($obj +".standard_bump")`;	

			if ($bump[0]=="")
				{
					
					print "no overal bump connected checking standard bump";
					print ("\n");

					
				}
			else
				{
					string $bumpcon=`connectionInfo -sfd ($bump[0] +".bumpValue")`;
					print $bumpcon;
					print ("\n");

						connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapR");
						connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapG");
						connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapB");
						float $bumpdepth=`getAttr ($bump[0]+".bumpDepth")`;
						print $bumpdepth;
						setAttr ($newMtl+".bumpMult") $bumpdepth;
				}

			if ($bump1[0]=="")
				{
					
					print "no bump connected";
					print ("\n");

					
				}
			else
				{
					string $bumpcon=`connectionInfo -sfd ($bump1[0] +".bumpValue")`;
					
						connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapR");
						connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapG");
						connectAttr -f $bumpcon ($newMtl +".bumpMap.bumpMapB");
						float $bumpdepth=`getAttr ($bump1[0]+".bumpDepth")`;
						setAttr ($newMtl+".bumpMult") $bumpdepth;
				}
// find the shading group

	string $SG[] = `listConnections -t shadingEngine $obj`;
	print $SG[0];
// connect the VRay shader to the shading group
	connectAttr -f ($newMtl +".outColor") ($SG[0] +".surfaceShader");
// delete the mia shader
// delete $obj;

}
//END MAYA2VRAY

global proc syncLightScales()
{
string $mySelection[] = `ls -sl`;
string $mySelectionShapes[] = `listRelatives -s $mySelection`;
string $mySphereLightsShapesToScale[] = `ls -exactType "VRayLightSphereShape" $mySelectionShapes`;
string $mySphereLightsTransformsToScale[] = `listRelatives -parent $mySphereLightsShapesToScale`;
string $myRectLightsShapesToScale[] = `ls -exactType "VRayLightRectShape" $mySelectionShapes`;
string $myRectLightsTransformsToScale[] = `listRelatives -parent $myRectLightsShapesToScale`;

if ( `size $myRectLightsTransformsToScale` > 0 )
	{
	//string $myRectLightSelection[] = $myRectLightsTransformsToScale;
	//for($each in $mySelection)
	for ($n=0 ; $n<size($myRectLightsTransformsToScale) ; $n++)
		{
		float $lightXscale = `getAttr ($myRectLightsTransformsToScale[$n] + ".scaleX")`;
		float $lightYscale = `getAttr ($myRectLightsTransformsToScale[$n] + ".scaleY")`;
		float $currentUsize = `getAttr ($myRectLightsTransformsToScale[$n] + ".uSize")`;
		float $currentVsize = `getAttr ($myRectLightsTransformsToScale[$n] + ".vSize")`;
		
		setAttr ($myRectLightsTransformsToScale[$n] + ".scaleX") 1;
		setAttr ($myRectLightsTransformsToScale[$n] + ".scaleY") 1;
		setAttr ($myRectLightsTransformsToScale[$n] + ".scaleZ") 1;
		setAttr ($myRectLightsTransformsToScale[$n] + ".uSize") ($lightXscale * $currentUsize);
		setAttr ($myRectLightsTransformsToScale[$n] + ".vSize") ($lightYscale * $currentVsize);
		}
	}

if ( `size $mySphereLightsTransformsToScale` > 0 )
	{
		for ($m=0 ; $m<size($mySphereLightsTransformsToScale) ; $m++)
		{
		float $lightXscale = `getAttr ($mySphereLightsTransformsToScale[$m] + ".scaleX")`;
		float $currentUsize = `getAttr ($mySphereLightsTransformsToScale[$m] + ".radius")`;
		
		setAttr ($mySphereLightsTransformsToScale[$m] + ".scaleX") 1;
		setAttr ($mySphereLightsTransformsToScale[$m] + ".scaleY") 1;
		setAttr ($mySphereLightsTransformsToScale[$m] + ".scaleZ") 1;
		setAttr ($mySphereLightsTransformsToScale[$m] + ".radius") ($lightXscale * $currentUsize);
		}
	}
}

global proc launchImapViewer()
{
string $version = `getApplicationVersionAsFloat`;

if ( `about -mac` )
	{
	system (("/Applications/ChaosGroup/V-Ray/Maya") + $version + ("-x64/bin/imapviewer &"));
	}
	else if ( `about -linux64` )
	{
	system (("/usr/autodesk/maya") + $version + ("-x64/vray/bin/imapviewer.exe"));
	}
	else if ( `about -win` )
	{
	system ("start C\:\\Program\ Files\\Chaos\ Group\\V-Ray\\Maya\ " + $version + ("\ for\ x64\\bin\\imapviewer.exe"));
	}
}

global proc Feedback()
{
if ( `about -mac` )
	{
	system ("open /Applications/Utilities/Console.app");
	}
	else if ( `about -win` )
	{
	error "This is the Maya Output Window on Windows.";
	}
}

global proc int VRnodeIsVisible( string $node )
{
  // If user is asking about a bogus node, return FALSE.
  if ( !`objExists $node` ) return false;

  // Object must be a DAG node, or it's not visible.
  // There's no MEL query to identify a DAG node, but the kDagNode class adds
  // the '.visibility' attribute, so we'll use its existence as a cue.
  if ( !`attributeQuery -node $node -exists "visibility"` ) return false;

  // The obvious: Start with the '.visibility' attribute on the node.
  int $visible = `getAttr ( $node + ".visibility" )`;

  // If this is an intermediate mesh, it's not visible.
  if ( `attributeQuery -node $node -exists "intermediateObject"` )
  {
    $visible = $visible && !`getAttr ( $node + ".intermediateObject" )`;
  }

  // If the object is in a displayLayer, and the displayLayer is hidden,
  // then the object is hidden.
  if ( `attributeQuery -node $node -exists "overrideEnabled"` &&
       `getAttr ( $node + ".overrideEnabled" )` )
  {
    $visible = $visible && `getAttr ( $node + ".overrideVisibility" )`;
  }

  // Ascend the hierarchy and check all of the parent nodes.
  if ( $visible )
  {
    string $parents[] = `listRelatives -parent $node`;
    if ( `size $parents` > 0 )
    {
      $visible = $visible && VRnodeIsVisible( $parents[0] );
    }
  }
  
  return $visible;
}

//FINAL V-RAY PERLIGHT LIGHT BATCH RENDERING WITH RENDER ELEMENTS
global proc perLightRender()
{
uniqueNamer();
 	
string $mySelectionToDetermine[] = `ls -sl`;
string $selection[] = `ls -sl -dag -lf`; 
string $selectionIsOfType[];
if ($selection[0] != "")
 	{
	$selectionIsOfType[0] = `nodeType $selection[0]`; 	
 	}
string $soloRenderLights[];

if(($selectionIsOfType[0] == "VRayLightDomeShape") || ($selectionIsOfType[0] == "VRaySunShape") || ($selectionIsOfType[0] == "VRayLightRectShape") || ($selectionIsOfType[0] == "VRayLightSphereShape") || ($selectionIsOfType[0] == "VRayLightIESShape") || ($selectionIsOfType[0] == "spotLight") || ($selectionIsOfType[0] == "pointLight") || ($selectionIsOfType[0] == "areaLight") || ($selectionIsOfType[0] == "directionalLight") ) 
	{
    $soloRenderLights = $selection;
    }
    
string $currentRenderLayer = `editRenderLayerGlobals -q -currentRenderLayer`;
string $allOnCurrentRenderLayer[] = `editRenderLayerMembers -q $currentRenderLayer`;
string $allOnCurrentRenderLayerShapes[] = `listRelatives -s $allOnCurrentRenderLayer`;

string $mySun[] = `ls -exactType "VRaySunShape"`;
string $myDomeLight[] = `ls -exactType "VRayLightDomeShape"`; 
string $myRectLights[] = `ls -exactType "VRayLightRectShape"`;
string $mySphereLights[] = `ls -exactType "VRayLightSphereShape"`;
string $myIESLights[] = `ls -exactType "VRayLightIESShape"`;
string $mySpotlights[] = `ls -exactType "spotLight"`;
string $myPointlights[] = `ls -exactType "pointLight"`;
string $myArealights[] = `ls -exactType "areaLight"`;
string $myDirectionallights[] = `ls -exactType "directionalLight"`;
int $frameStamp = `currentTime -q`;
string $pad = `python ("'%04d' % "+$frameStamp)`;
string $docName = ("perLight." + $pad + ".");
int $RE_value = `getAttr vraySettings.relements_enableall`;

select -cl; 

for ($n=0 ; $n<size($myDomeLight) ; $n++)
{
    if( size($myDomeLight) > 0 && (stringArrayContains( $myDomeLight[$n], $allOnCurrentRenderLayerShapes)) )
	{  
	select -add $myDomeLight[$n];
	}
	if (getAttr ($myDomeLight[$n] + ".enabled") == 0)
	{
	select -d $myDomeLight[$n];
	}
}
for ($n=0 ; $n<size($mySun) ; $n++)
{
    if( size($mySun) > 0 && (stringArrayContains( $mySun[$n], $allOnCurrentRenderLayerShapes)) )
    {  
	select -add $mySun[$n];
	}
	if (getAttr ($mySun[$n] + ".enabled") == 0)
	{
		select -d $mySun[$n];
	}
}
for ($n=0 ; $n<size($myRectLights) ; $n++)
{
    if( size($myRectLights) > 0 && (stringArrayContains( $myRectLights[$n], $allOnCurrentRenderLayerShapes)) )
	{  
    select -add $myRectLights[$n];
	}
	if (getAttr ($myRectLights[$n] + ".enabled") == 0)
	{
		select -d $myRectLights[$n];
	}
}
for ($n=0 ; $n<size($mySphereLights) ; $n++)
{
	if( size($mySphereLights) > 0 && (stringArrayContains( $mySphereLights[$n], $allOnCurrentRenderLayerShapes)) )
	{  
	select -add $mySphereLights[$n];
	if (getAttr ($mySphereLights[$n] + ".enabled") == 0)
	{
		select -d $mySphereLights[$n];
	}
	}
}
for ($n=0 ; $n<size($myIESLights) ; $n++)
{
    if( size($myIESLights) > 0 && (stringArrayContains( $myIESLights[$n], $allOnCurrentRenderLayerShapes)) )
	{  
    select -add $myIESLights[$n];
	}
	if (getAttr ($myIESLights[$n] + ".enabled") == 0)
	{
	select -d $myIESLights[$n];
	}
}
for ($n=0 ; $n<size($myPointlights) ; $n++)
{
    if( size($myPointlights) > 0 && (stringArrayContains( $myPointlights[$n], $allOnCurrentRenderLayerShapes)) )
	{  
    select -add $myPointlights[$n];
	}
}
for ($n=0 ; $n<size($mySpotlights) ; $n++)
{
    if( size($mySpotlights) > 0 && (stringArrayContains( $mySpotlights[$n], $allOnCurrentRenderLayerShapes)) )
	{  
    select -add $mySpotlights[$n];
	}
}
for ($n=0 ; $n<size($myDirectionallights) ; $n++)
{
    if( size($myDirectionallights) > 0 && (stringArrayContains( $myDirectionallights[$n], $allOnCurrentRenderLayerShapes)) )
	{  
    select -add $myDirectionallights[$n];
	}
}
for ($n=0 ; $n<size($myArealights) ; $n++)
{
    if( size($myArealights) > 0 && (stringArrayContains( $myArealights[$n], $allOnCurrentRenderLayerShapes)) )
	{  
    select -add $myArealights[$n];
	}
}
//change this to populate array when read, not selections
string $allObjects[] = `ls -sl`;

//CHECK TO SEE IF THERE IS VIGNETTING ON
//$currentCam = `getCurrentCamera`;
//select $currentCam;
//string $goodCamShapy[] = `ls -sl -dag -lf`;
//  if ((`attributeExists "vrayCameraPhysicalVignetting" $goodCamShapy[0]`) && (`getAttr ($goodCamShapy[0] + ".vrayCameraPhysicalVignetting")` == 1)) 
//  {
//	error "Your camera has vignetting on and this will compound when compositing light passes\n";
//  }

//manually selected mesh lights here//
//store and zero meshlights
string $shapes[];
string $sGroup[];
string $sGroupMat[];
float $myStoredMultipliers[];
string $temporary[]; // declare temp array
string $connectedToSelfIllum[];
vector $myStoredSelfIllumRGBVector[];
string $sGroupMeshSelectionVRayMat[];
string $sGroupMeshSelectionVRayLightMat[];


//BUILD AND POPULATE MAT MULTIPLIER ARRAYS
if ($selection[0] != "")//if selection wasn't empty, populate them
{
 if ( (`nodeType $selection[0]` == "mesh") && ($soloRenderLights[0] == ""))
 {
	//get the name of the shapes and put in string array
	for ($n=0 ; $n<size($mySelectionToDetermine) ; $n++)
	{
		$temporary = `listRelatives -s $mySelectionToDetermine[$n]`; // assign results to $tmp array
		$shapes[$n] = $temporary[0]; // assign 1st item in $tmp array to $shapes[$n] in each loop
	}

	//get the shape subgroups and put in string array
	for ($n=0 ; $n<size($mySelectionToDetermine) ; $n++)
	{
	  $temporary = `listSets -type 1 -o $shapes[$n]`; // assign results to $tmp array
	  $sGroup[$n] = $temporary[0]; // assign 1st item in $tmp array to $shapes[$n] in each loop
	}
	
	//get the Mat and put in string array
	for ($n=0 ; $n<size($mySelectionToDetermine) ; $n++)
	{
	  $temporary = `listConnections -d 0 -s 1 $sGroup[$n]`; // assign results to $tmp array
	  $sGroupMat[$n] = $temporary[0]; // assign 1st item in $tmp array to $shapes[$n] in each loop
	}

//STORE CONNECTIONS AND VALUES FOR MESHLIGHTS and VRAY SELF-ILLUM
for ($n=0 ; $n<size($sGroupMat) ; $n++)
		{
		string $testMater[];
		$testMater[$n] = `objectType $sGroupMat[$n]`;
		
		if ($testMater[$n] == "VRayMtl")
			{
			$sGroupMeshSelectionVRayMat[$n] = $sGroupMat[$n];
			$myStoredSelfIllumRGBVector[$n] = `getAttr ($sGroupMeshSelectionVRayMat[$n] + ".illumColor")`;
			print " line 3063";
			//float $tempFloatRGB[] = $myStoredSelfIllumRGBVector[$n];
			//get gamma connection
			string $tempCheck[] = `listConnections -s 1 -d 1 ($sGroupMeshSelectionVRayMat[$n] + ".illumColor")`;
			
			if ($tempCheck[0] != "")//it's connected to a node 
					{
					$connectedToSelfIllum[$n] = $tempCheck[0];
					//if it's not connected to an outvalue, it's a direct file connection
					if (`objectType $connectedToSelfIllum[$n]` == "file")
						{
						//break the file connection
						disconnectAttr ($connectedToSelfIllum[$n] + ".outColor") ($sGroupMeshSelectionVRayMat[$n] + ".illumColor");
						}
					else
						{
						//store gamma node connection
						//I'm assuming this is a gamma correct or multiply, etc (outValue)
						disconnectAttr ($connectedToSelfIllum[$n] + ".outValue") ($sGroupMeshSelectionVRayMat[$n] + ".illumColor");//populate another array of gamma corrected mats with these
						}	
					}
			
			//zero it 
			setAttr ($sGroupMeshSelectionVRayMat[$n] + ".illumColor") -type double3 0 0 0 ;//zeroed
			}
		if ($testMater[$n] == "VRayLightMtl")
			{
			$sGroupMeshSelectionVRayLightMat[$n] = $sGroupMat[$n];
			$myStoredMultipliers[$n] = `getAttr ($sGroupMeshSelectionVRayLightMat[$n] + ".colorMultiplier")`;
			setAttr ($sGroupMeshSelectionVRayLightMat[$n] + ".colorMultiplier") 0;
			}
		}
	}
}
//INITIALIZE VRAYFILENAMEPREFIX STRING
unifiedRenderGlobalsWindow;

string $currentRenderName = `textFieldGrp -q -text -forceChangeCommand vrayFileNamePrefix`;
int $envMapState = `getAttr "vraySettings.cam_overrideEnvtex"`;
if ($envMapState == 1)
	{
	setAttr "vraySettings.cam_overrideEnvtex" 0;
	}

//render each light contribution
for ( $obj in $allObjects ) 
{
    hide $allObjects;
    //show meshlight object with dimmed light contribution
    if (($selection[0] != "") && ($soloRenderLights[0] != "") )//if selection wasn't empty, populate them
		{
			 if ( `nodeType $selection[0]` == "mesh" )
				{
				showHidden $mySelectionToDetermine;// this is still presuming it's a mesh light and it wants its dimmed contrib
				showHidden $obj;
				}
    	
			//if selection wasn't empty, it was a Vray light and $obj was selected, render it only
			else if (($selectionIsOfType[0] == "VRayLightDomeShape") || ($selectionIsOfType[0] == "VRaySunShape") || ($selectionIsOfType[0] == "VRayLightRectShape") || ($selectionIsOfType[0] == "VRayLightSphereShape") || ($selectionIsOfType[0] == "VRayLightIESShape") || ($selectionIsOfType[0] == "spotLight") || ($selectionIsOfType[0] == "pointLight") || ($selectionIsOfType[0] == "areaLight") || ($selectionIsOfType[0] == "directionalLight") ) 
					{
					//for loop to only show selected V-Ray lights 
					showHidden $mySelectionToDetermine;
					//showHidden $obj;
					}
		}	
	else showHidden $obj;

//TEST FOR ACTUAL VISIBILITY
	if ( `VRnodeIsVisible $obj` == 1 )
		{
		textFieldGrp -e -text ($docName + "_" + $obj) -forceChangeCommand vrayFileNamePrefix;
		RedoPreviousRender;
		showHidden $allObjects;
		} 
}

//set LIGHT MAT MULT for MESH to current value and render each mesh light contribution
for ($n=0 ; $n<size($sGroupMat) ; $n++)
	{
	hide $allObjects;
	string $testMater[];
	$testMater[$n] = `objectType $sGroupMat[$n]`;
	if ($testMater[$n] == "VRayLightMtl")
		{
		setAttr ($sGroupMeshSelectionVRayLightMat[$n] + ".colorMultiplier") $myStoredMultipliers[$n];
		textFieldGrp -e -text ($docName + "_" + $sGroupMeshSelectionVRayLightMat[$n]) -forceChangeCommand vrayFileNamePrefix;
		//restore gamma correct connection
		
		//if no gamma correct: 
		RedoPreviousRender;
		setAttr ($sGroupMeshSelectionVRayLightMat[$n] + ".colorMultiplier") 0;
		}	
	//set VRAY MAT RGB SELF ILLUM for MESH to current value and render each mesh light contribution
	else if ($testMater[$n] == "VRayMtl")
		{
		//if no gamma correct, just set original colour values: 
		float $tempFloatRGB[] = $myStoredSelfIllumRGBVector[$n];
		setAttr ($sGroupMeshSelectionVRayMat[$n] + ".illumColor") -type double3 $tempFloatRGB[0] $tempFloatRGB[1] $tempFloatRGB[2];
		
		//restore gamma correct connection or file connection
		string $tempCheck[]; 
		$tempCheck[0] = $connectedToSelfIllum[$n];//make a check to see if there was a connection to $sGroupMeshSelectionVRayMat[$n] originally on line 3070
		if ($tempCheck[0] != "")//it was connected to a node if it's not empty
			{
			//check if connection is file or gamma node
			if (`objectType $connectedToSelfIllum[$n]` == "file")
				{
				connectAttr ($connectedToSelfIllum[$n] + ".outColor") ($sGroupMeshSelectionVRayMat[$n] + ".illumColor");
				}		
			else//assume it's a gamma correct
				{
				connectAttr ($connectedToSelfIllum[$n] + ".outValue") ($sGroupMeshSelectionVRayMat[$n] + ".illumColor");
				}
			}
		
		textFieldGrp -e -text ($docName + "_" + $sGroupMeshSelectionVRayMat[$n]) -forceChangeCommand vrayFileNamePrefix;
		RedoPreviousRender;
		
		string $tempCheck[] = `listConnections -s 1 -d 1 ($sGroupMeshSelectionVRayMat[$n] + ".illumColor")`;	
		if ($tempCheck[0] != "")//it's connected to a node
			{
			if (`objectType $connectedToSelfIllum[$n]` == "file")
				{
				disconnectAttr ($connectedToSelfIllum[$n] + ".outColor") ($sGroupMeshSelectionVRayMat[$n] + ".illumColor");
				}		
			else//assume it's a gamma correct
				{
				disconnectAttr ($connectedToSelfIllum[$n] + ".outValue") ($sGroupMeshSelectionVRayMat[$n] + ".illumColor");
				}
			}
		setAttr ($sGroupMeshSelectionVRayMat[$n] + ".illumColor") -type double3 0 0 0;
		}
	}

//render environment map only contribution
if ($envMapState == 1) 
{
	setAttr "vraySettings.cam_overrideEnvtex" 1;
	hide $allObjects;
	//show meshlight object with dimmed light contribution 
	showHidden $mySelectionToDetermine;
	textFieldGrp -e -text ($docName + "environment_render") -forceChangeCommand vrayFileNamePrefix;
	if ($soloRenderLights[0] == "")
	{
	RedoPreviousRender;
	}
}

//RESTORE STARTING STATE
    showHidden $allObjects;
	//show meshlight object with dimmed light contribution 
	textFieldGrp -e -text "" -forceChangeCommand vrayFileNamePrefix;
	textFieldGrp -e -text $currentRenderName -forceChangeCommand vrayFileNamePrefix;

//restore mesh multiplier starting state
for ($n=0 ; $n<size($sGroupMat) ; $n++)
{
	string $testMater[];
	$testMater[$n] = `objectType $sGroupMat[$n]`;
		
	if ($testMater[$n] == "VRayLightMtl")
		{
		setAttr ($sGroupMeshSelectionVRayLightMat[$n] + ".colorMultiplier") $myStoredMultipliers[$n];
		}
	if ($testMater[$n] == "VRayMtl")
	//restore self illum values and reconnect disconnected nodes
		{
		float $tempFloatRGB[] = $myStoredSelfIllumRGBVector[$n];
		setAttr ($sGroupMeshSelectionVRayMat[$n] + ".illumColor") $tempFloatRGB[0] $tempFloatRGB[1] $tempFloatRGB[2];
		//connect the gamma corrected swatch
		string $tempCheck[]; 
		$tempCheck[0] = $connectedToSelfIllum[$n];//make a check to see if there was a connection to $sGroupMeshSelectionVRayMat[$n] originally on line 3070
		if ($tempCheck[0] != "")//it was connected to a node if it's not empty
			{
			if (`objectType $connectedToSelfIllum[$n]` == "file")
				{
				connectAttr ($connectedToSelfIllum[$n] + ".outColor") ($sGroupMeshSelectionVRayMat[$n] + ".illumColor");
				}		
			else//assume it's a gamma correct
				{
				connectAttr ($connectedToSelfIllum[$n] + ".outValue") ($sGroupMeshSelectionVRayMat[$n] + ".illumColor");
				}
			}	
		}
}

if ($RE_value == 1)
{
setAttr "vraySettings.relements_enableall" 1;
}

deleteUI -window unifiedRenderGlobalsWindow;
}

global proc printVRayInfo()
{
int $primaryE = `getAttr vraySettings.primaryEngine`;
int $secondaryE = `getAttr vraySettings.secondaryEngine`;
string $primes[] = { "Irradiance Map", "Photon Map", "Brute Force", "Light Cache", "Spherical Harmonics" };
string $second[] = { "None", "Photon Map", "Brute Force", "Light Cache" };
int $activeIMMode = `getAttr vraySettings.imap_mode`;
string $imMode[] = { "IMap: Single Frame", "IMAP: Multi-frame incremental", "IMap: From File", "IMap: Add to Current Map", "IMAP: Incremental Add", "IMAP: Bucket Mode", "IMAP: Animation (prepass)", "IMAP: Animation (rendering)" } ;
int $activeLCMode = `getAttr vraySettings.mode`;
string $lcMode[] = { "Light Cache: Single Frame", "Light Cache: Fly-through", "Light Cache: From File", "Light Cache: PPT" } ;

print (("V-Ray Info: Primary Engine is " + $primes[$primaryE] + ", Secondary Engine is " + $second[$secondaryE]) + (". Lightmaps: " + $imMode[$activeIMMode]) + " / " + ($lcMode[$activeLCMode]) + "\n");
}

global proc dirtPassToggle() {
  	
  	global int $dirtPass;
  	global int $composite;
  	$dirtPass = !$dirtPass;
  
  	checkBox -edit
  		-enable ($dirtPass)
  		"compositeCheck";
  	
  	if (!$dirtPass) {
		 checkBox -edit -value 0	"compositeCheck";
		 $composite = 0;
	}
  }
  
global proc compositeToggle() {
  	global int $composite;
  	$composite = !$composite;
  }

global proc daveBakeUI()
{
//The GUI
global int $dirtPass;
global int $composite;
global int $buildDirtShader;

if ( `window -exists daveBaker` )
  deleteUI -window daveBaker;
string $daveBaker = `window -title "DaveBake420" -sizeable 0 daveBaker`;
columnLayout -adjustableColumn true -columnAttach "both" 8;
columnLayout;
separator -style "none" -w 240 -h 12;

text "If this is the first time you are running the script,";
text "open Render Settings to initialize or it could fail";
separator -style "none" -w 120 -h 5;

button -w 340 -h 20 -l "Render Settings" -ann ""-c "unifiedRenderGlobalsWindow;";
separator -style "none" -w 240 -h 6;
text "If don't use any of the settings below, you will bake"; 
text "all materials and render elements for selected objects";
separator -style "none" -h 5;
//checkBox -l "Composite diffuse colour with V-Ray Dirt RE" -ann "Make a multiply/divide utility with diffuse colour multiplied by the dirt render" -v $dirtPass -cc "dirtPassToggle()" "dirtPassCheck";
checkBox -l "Composite diffuse colour with V-Ray Dirt RE" -ann "Make a multiply/divide utility with diffuse colour multiplied by the dirt render" -changeCommand "dirtPassToggle()" -v $dirtPass "dirtPassCheck";
checkBox -l "Use pre-baked diffuse colour for above" -value false -enable $dirtPass -ann "Multiply/divide utility with pre-baked diffuse colour multiplied by the dirt render" "compositeCheck";
//checkBox -l "Apply above to existing material's diffuse" -value $composite -enable ($dirtPass) -ann "" -changeCommand "compositeToggle()" "compositeCheck";
checkBox -l "Save as new scene_baked on complete" -ann "This helps ensure you don't overwrite your current scene with all new mats" -value false daveBakerCheckbox4;

checkBox -l "Move baked images to sourceimages after render" -v false daveBakerCheckbox1;

setParent ..;
columnLayout;

separator -style "none" -h 12;
button -w 340 -h 30 -l "Get Baked" -ann "Dave Bake 420."-c "daveBake420;";
setParent ..;
separator -style "none" -w 240 -h 12;
showWindow $daveBaker;
}

global proc daveBake420()
{
setAttr "vraySettings.aspectLock" 0;
string $mySelection[] = `ls -sl`;
global int $dirtPass;
global int $composite;
global int $moveAOStatus;
global int $preBakedDiffuse;
$preBakedDiffuse = `checkBox -q -v "compositeCheck"`; 
$moveAOStatus = `checkBox -q -v daveBakerCheckbox1`;
global int $gammaCorectBakes;
//$gammaCorectBakes = `checkBox -q -v daveBakerCheckbox3`;
//checkBox -l "Apply gamma correct to new baked textures" -value false -enable ($dirtPass) -changeCommand "compositeToggle()" "degammaChecker";
global int $saveNewSceneCheck;
$saveNewSceneCheck = `checkBox -q -v daveBakerCheckbox4`;

unifiedRenderGlobalsWindow;
optionMenuGrp -e -sl 2 vrayBakingEngineCtrl;
attrControlGrp -edit -enable 1 vrayBakeChannelCtrl;
attrControlGrp -edit -enable 1 vrayBakeDilationCtrl;
setAttr "vraySettings.bakeRender" 1;
attrControlGrp -edit -enable 1 vrayBakeUMin;
attrControlGrp -edit -enable 1 vrayBakeVMin;
attrControlGrp -edit -enable 1 vrayBakeUMax;
attrControlGrp -edit -enable 1 vrayBakeVMax;

int $currentResWidth = `getAttr "vraySettings.width"`;
int $currentResHeight = `getAttr "vraySettings.height"`;
setAttr "vraySettings.width" 4096;
setAttr "vraySettings.height" 4096;
$resmenuSelection = `optionMenuGrp -q -v resMenu`;
if ($resmenuSelection == "10%")
	{
	setAttr "vraySettings.width" 5120;
	setAttr "vraySettings.height" 5120;	
	}

vrayUpdateResolution();
string $fileExten = `getAttr "vraySettings.imageFormatStr"`;
/////TO DO: ADD A CHECK TO MAKE SURE RENDER COMPLETED CORRECTLY AND FILE EXISTS BEFORE ATTEMPTING TO COMP
string $currentRenderName = `textFieldGrp -q -text -forceChangeCommand vrayFileNamePrefix`;

if ($dirtPass == 1)
{
//	if ($composite == 1)//build multiplied shader and attach it to diffuse channel
//		{
//		for ($n=0 ; $n<size($mySelection) ; $n++)
//			{
//			select -r $mySelection[$n];
//			textFieldGrp -e -text $mySelection[$n] -forceChangeCommand vrayFileNamePrefix;
//			RedoPreviousRender;
//			string $projPath = `workspace -q -rd`;
//			
//			string $renderFileName = ($projPath + "/images/tmp/" + $mySelection[$n] + "." + $fileExten);
//			if ($moveAOStatus == 1)
//				{
//				$renderFileName = ($projPath + "/sourceimages/" + $mySelection[$n] + "." + $fileExten);
//				}
//			int $fileExists = `file -q -exists $renderFileName`;
//
//			if ($fileExists)
//				{
//				print ($mySelection[$n] + "baked\n");
//				string $bakedAOFile = `shadingNode -asTexture file`;
//				rename $bakedAOFile ($mySelection[$n] + "_AO");
//				string $bakedDiffuseFile = `shadingNode -asTexture file`;
//				rename $bakedAOFile ($mySelection[$n] + "_colour");
//				setAttr -type "string" ($bakedAOFile + ".fileTextureName") ($projPath + "/images/tmp/" + $mySelection[$n] + ".extraTex_VRayDirt1." + $fileExten);
//				setAttr -type "string" ($bakedDiffuseFile + ".fileTextureName") ($projPath + "/images/tmp/" + $mySelection[$n] + "." + $fileExten);
//				string $multUtil = `shadingNode -asUtility multiplyDivide`;
//				connectAttr -f ($bakedAOFile + ".outColorR") ($multUtil + ".input1X");
//				connectAttr -f ($bakedAOFile + ".outColorG") ($multUtil + ".input1Y");
//				connectAttr -f ($bakedAOFile + ".outColorB") ($multUtil + ".input1Z");
//				connectAttr -f ($bakedDiffuseFile + ".outColorR") ($multUtil + ".input2X");
//				connectAttr -f ($bakedDiffuseFile + ".outColorG") ($multUtil + ".input2Y");
//				connectAttr -f ($bakedDiffuseFile + ".outColorB") ($multUtil + ".input2Z");
//				//string $shaderTypeToBuild = `optionMenuGrp -q -v bbSettingXMenu`;
//
////				switch($shaderTypeToBuild) {
////	//			   case "V-Ray Material":
////	//				  $shape = "circle";
////	//				  break;
////				   case "Maya Lambert":
////					  string $newLambert = `shadingNode -asShader lambert`;
////					  assignCreatedShader $newLambert "" $newLambert $mySelection[$n];
////					  connectAttr -force ($multUtil + ".output") ($newLambert + ".color");
////					  break;
////				   case "Maya Blinn":
////					  string $newBlinn = `shadingNode -asShader blinn`;
////					  assignCreatedShader $newBlinn "" $newBlinn $mySelection[$n];
////					  connectAttr -force ($multUtil + ".output") ($newBlinn + ".color");
////					  break;
////					case "Maya Phong":
////					  string $newPhong = `shadingNode -asShader phong`;
////					  assignCreatedShader $newPhong "" $newPhong $mySelection[$n];
////					  connectAttr -force ($multUtil + ".output") ($newPhong + ".color");
////					  break;
////	//			   default:
////	//				  $shape = "cylinder";
////					}			
//			   }
//			   }
//			}
//	else if ($composite == 0)
//		{
	for ($n=0 ; $n<size($mySelection) ; $n++)
		{
		//query current diffuse connection
		string $shapes[] = `listRelatives -s $mySelection[$n]`;
		string $sGroup[] = `listSets -type 1 -o $shapes[0]`;
		string $currentSurfaceShader[] = `listConnections ($sGroup[0] + ".surfaceShader")`;
		string $connectedDiffuse; 
		string $tmpConnect[] = `listConnections ($currentSurfaceShader[0] + ".color")`;
		string $connectedDiffuse = $tmpConnect[0]; 
		string $typeTestDiffuse[] = `ls -showType $connectedDiffuse`;
		
		if ( $connectedDiffuse == "" )//just swatch with no connection so it needs a gamma correct to hold the diffuse value
			{
				select -r $mySelection[$n];
				textFieldGrp -e -text $mySelection[$n] -forceChangeCommand vrayFileNamePrefix;
				RedoPreviousRender;
				print ($mySelection[$n] + " baked\n");
				string $projPath = `workspace -q -rd`;
				string $bakedAOFile = `shadingNode -asTexture file`;
				string $bakedDiffuseFile = `shadingNode -asTexture file`;
				
				//make a gamma node to store the RGB diffuse values
				float $storedRGBb[3] = `getAttr ($currentSurfaceShader[0] + ".color")`;
				
				string $gammaNode = `shadingNode -asUtility gammaCorrect`;
				setAttr ($gammaNode + ".value") -type double3 $storedRGBb[0] $storedRGBb[1] $storedRGBb[2];
				
				if ($moveAOStatus == 1)
					{
					sysFile -move ($projPath + "/sourceimages/" + $mySelection[$n] + ".extraTex_VRayDirt1." + $fileExten) ($projPath + "/images/tmp/" + $mySelection[$n] + ".extraTex_VRayDirt1." + $fileExten) ;
					setAttr -type "string" ($bakedAOFile + ".fileTextureName") ($projPath + "/sourceimages/" + $mySelection[$n] + ".extraTex_VRayDirt1." + $fileExten);
					sysFile -move ($projPath + "/sourceimages/" + $mySelection[$n] + "." + $fileExten) ($projPath + "/images/tmp/" + $mySelection[$n] + "." + $fileExten) ;
					setAttr -type "string" ($bakedDiffuseFile + ".fileTextureName") ($projPath + "/sourceimages/" + $mySelection[$n] + "." + $fileExten);
					}
				else if ($moveAOStatus == 0)
					{
					setAttr -type "string" ($bakedAOFile + ".fileTextureName") ($projPath + "/images/tmp/" + $mySelection[$n] + ".extraTex_VRayDirt1." + $fileExten);
					}
				string $multUtil = `shadingNode -asUtility multiplyDivide`;
				if ($preBakedDiffuse)//don't use baked texture for diffuse
					{
					connectAttr -f ($gammaNode + ".outValue") ($multUtil + ".input2");//make these gamma util
					}
				else if ($preBakedDiffuse == 0)
					{
					setAttr -type "string" ($bakedDiffuseFile + ".fileTextureName") ($projPath + "/images/tmp/" + $mySelection[$n] + "." + $fileExten);
					//grab baked diffuse for gamma correct
					connectAttr -f ($bakedDiffuseFile + ".outColor") ($multUtil + ".input2");
					}
				connectAttr -f ($bakedAOFile + ".outColor") ($multUtil + ".input1");
				connectAttr -force ($multUtil + ".output") ($currentSurfaceShader[0] + ".color");
			}

		else if  ( $connectedDiffuse != "" )
			{
			select -r $mySelection[$n];
			textFieldGrp -e -text $mySelection[$n] -forceChangeCommand vrayFileNamePrefix;
			RedoPreviousRender;
			print ($mySelection[$n] + " baked\n");
			string $projPath = `workspace -q -rd`;
			string $bakedAOFile = `shadingNode -asTexture file`;
			string $bakedDiffuseFile = `shadingNode -asTexture file`;
			//GET RENDER ELEMENTS AND MOVE THEM
			if ($moveAOStatus == 1)
				{
				sysFile -move ($projPath + "/sourceimages/" + $mySelection[$n] + ".extraTex_VRayDirt1." + $fileExten) ($projPath + "/images/tmp/" + $mySelection[$n] + ".extraTex_VRayDirt1." + $fileExten) ;
				setAttr -type "string" ($bakedAOFile + ".fileTextureName") ($projPath + "/sourceimages/" + $mySelection[$n] + ".extraTex_VRayDirt1." + $fileExten);
				 if ($preBakedDiffuse == 0)//don't use baked texture for diffuse
					{
					sysFile -move ($projPath + "/sourceimages/" + $mySelection[$n] + "." + $fileExten) ($projPath + "/images/tmp/" + $mySelection[$n] + "." + $fileExten) ;
					setAttr -type "string" ($bakedDiffuseFile + ".fileTextureName") ($projPath + "/sourceimages/" + $mySelection[$n] + "." + $fileExten);
					}
				}
			else if ($moveAOStatus == 0)
				{
				setAttr -type "string" ($bakedAOFile + ".fileTextureName") ($projPath + "/images/tmp/" + $mySelection[$n] + ".extraTex_VRayDirt1." + $fileExten);
				 if ($preBakedDiffuse == 0)//don't use baked texture for diffuse
					{
					setAttr -type "string" ($bakedDiffuseFile + ".fileTextureName") ($projPath + "/images/tmp/" + $mySelection[$n] + "." + $fileExten);
					}
				}		
					
			string $multUtil = `shadingNode -asUtility multiplyDivide`;
			connectAttr -f ($bakedAOFile + ".outColor") ($multUtil + ".input1");
			
			if ($preBakedDiffuse)
				{
				if ($typeTestDiffuse[1] == "file")
					{
					//below assumes image file
					connectAttr -f ($connectedDiffuse + ".outColor") ($multUtil + ".input2");
					}
				else if ($typeTestDiffuse[1] == "gammaCorrect")
					{
					//below assumes gamma correct
					connectAttr -f ($connectedDiffuse + ".outValue") ($multUtil + ".input2");
					}
				}
			else if ($preBakedDiffuse == 0)
				{
				connectAttr -f ($bakedDiffuseFile + ".outColor") ($multUtil + ".input2");
				}
			connectAttr -force ($multUtil + ".output") ($currentSurfaceShader[0] + ".color");
			}
		}
//		}
}
else if ($dirtPass == 0)
	{
	for ($n=0 ; $n<size($mySelection) ; $n++)
		{
		select -r $mySelection[$n];
		textFieldGrp -e -text $mySelection[$n] -forceChangeCommand vrayFileNamePrefix;
		RedoPreviousRender;
		print ($mySelection[$n] + "baked\n");
		if ($moveAOStatus == 1)
				{
				string $projPath = `workspace -q -rd`;
				sysFile -move ($projPath + "/sourceimages/" + $mySelection[$n] + ".extraTex_VRayDirt1." + $fileExten) ($projPath + "/images/tmp/" + $mySelection[$n] + ".extraTex_VRayDirt1." + $fileExten) ;;//dirt
				sysFile -move ($projPath + "/sourceimages/" + $mySelection[$n] + "." + $fileExten) ($projPath + "/images/tmp/" + $mySelection[$n] + "." + $fileExten) ;//diffuse
				}
		}
	}

textFieldGrp -e -text "" -forceChangeCommand vrayFileNamePrefix;
//restore starting settings
textFieldGrp -e -text $currentRenderName -forceChangeCommand vrayFileNamePrefix;
setAttr "vraySettings.width" $currentResWidth;
setAttr "vraySettings.height" $currentResHeight;
vrayUpdateResolution();

//reinstate original settings
//setAttr "vraySettings.sh_export_on" $sh_export_current;
optionMenuGrp -e -sl 1 vrayBakingEngineCtrl;
attrControlGrp -edit -enable 0 vrayBakeChannelCtrl;
attrControlGrp -edit -enable 0 vrayBakeDilationCtrl;
setAttr "vraySettings.bakeRender" 0;
attrControlGrp -edit -enable 0 vrayBakeUMin;
attrControlGrp -edit -enable 0 vrayBakeVMin;
attrControlGrp -edit -enable 0 vrayBakeUMax;
attrControlGrp -edit -enable 0 vrayBakeVMax;
deleteUI -window unifiedRenderGlobalsWindow;


if ($saveNewSceneCheck == 1)
	{
		//string $projectDirect = `workspace -q -rd`;
		string $fine = `file -q -sn`; 
		string $bufferName[];
		tokenize $fine "." $bufferName;
		file -rename ($bufferName[0] + "_baked");
		file -save;
	}
}
//END DAVEBAKE420

global proc connectCamExp()
{
string $mySelection[] = `ls -sl -ca -dag`;
connectControl vraytunerslider20 ($mySelection[0] + ".overscan");
int $physCamChecker = `attributeQuery -node $mySelection[0] -exists "vrayCameraPhysicalOn"`;
if ($physCamChecker == 0)
	{
	//prompt
	string $confirmRes = `confirmDialog -title "Add physical cam attributes to selected cam?"
    -button "Yes" -button "No" -defaultButton "Yes"
    -cancelButton "No" -dismissString "No"`;

	if ($confirmRes == "Yes")
		{
		for ($n=0 ; $n<size($mySelection) ; $n++)
			{
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalOn; 
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalType;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalFilmWidth;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalFocalLength;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalSpecifyFOV;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalFOV;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalZoomFactor;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalDistortionType;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalDistortion;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalLensFile;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalDistortionMap;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalFNumber;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalHorizLensShift;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalLensShift;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalLensAutoVShift;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalShutterSpeed;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalShutterAngle;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalShutterOffset;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalLatency;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalISO;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalSpecifyFocus;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalFocusDistance;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalExposure;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalWhiteBalance;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalVignetting;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalVignettingAmount;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalBladesEnable;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalBladesNum;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalBladesRotation;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalCenterBias;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalAnisotropy;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalUseDof;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalUseMoBlur;
			vrayAddAttr $mySelection[$n] vrayCameraPhysicalSubdivs;
			setAttr ($mySelection[$n] + ".vrayCameraPhysicalOn") 1;
			select -r $mySelection[$n];
			}
		}
	}

connectControl vraytunerslider19 ($mySelection[0] + ".vrayCameraPhysicalFNumber");
connectControl vraytunerslider18 ($mySelection[0] + ".vrayCameraPhysicalISO");

}

//START GI PICKER
global proc readGI()
{
$currentGImenuSelection = `optionMenuGrp -q -v GImenu`;
int $primaryMode; 
int $GImode;
int $cacheGIMode = `getAttr vraySettings.imap_mode`;
$primaryE = `getAttr vraySettings.primaryEngine`;
$secondaryE = `getAttr vraySettings.secondaryEngine`;	


	if ( $currentGImenuSelection == "GI Scheme")
		$primaryMode = $primaryE;
	else if ( $currentGImenuSelection == "IM/BF")
		$primaryMode = 0;
	else if ( $currentGImenuSelection == "BF/LC")
		$primaryMode = 2;
	else if ( $currentGImenuSelection == "IM/LC")
		$primaryMode = 0;
	else if ( $currentGImenuSelection == "BF/Ph")
		$primaryMode = 2;	
	else if ( $currentGImenuSelection == "BF/BF")
		$primaryMode = 2;	
	else if ( $currentGImenuSelection == "LC/LC")
		$primaryMode = 3;		
		
	if ( $currentGImenuSelection == "GI Scheme")
		$GImode = $secondaryE;
	else if ( $currentGImenuSelection == "IM/BF")
		$GImode = 2;	
	else if ( $currentGImenuSelection == "BF/LC")
		$GImode = 3;
	else if ( $currentGImenuSelection == "IM/LC")
		$GImode = 3;
	else if ( $currentGImenuSelection == "BF/Ph")
		$GImode = 1;
	else if ( $currentGImenuSelection == "BF/BF")
		$GImode = 2;
	else if ( $currentGImenuSelection == "LC/LC")
		$GImode = 3;
		
setAttr vraySettings.primaryEngine $primaryMode;
setAttr vraySettings.secondaryEngine $GImode;

printVRayInfo();
}
//END GI PICKER

//START ANTIALIASING CONTROLS
global proc AAcommand()
{
$AAmenuSelection = `optionMenuGrp -q -v AAmenu`;
int $AA; 
float $filterSize;
$currentAA = `getAttr vraySettings.samplerType`;
$currentAAFilter = `getAttr vraySettings.aaFilterType`;


	if ( $AAmenuSelection == "setDMC")
		$AA = $currentAA;
	else if ( $AAmenuSelection == "Box")
		$AA = 0;
	else if ( $AAmenuSelection == "Area")
		$AA = 1;
	else if ( $AAmenuSelection == "Tri")
		$AA = 2;
	else if ( $AAmenuSelection == "Lnczs")
		$AA = 3;
	else if ( $AAmenuSelection == "Sinc")
		$AA = 4;	
	else if ( $AAmenuSelection == "CatRm")
		$AA = 5;
	else if ( $AAmenuSelection == "Gauss")
		$AA = 6;
	else if ( $AAmenuSelection == "CkVar")
		$AA = 7;
	
	if ( $AAmenuSelection == "AA")
		$filterSize = $currentAAFilter;
	else if ( $AAmenuSelection == "Box")
		$filterSize = 1.5;
	else if ( $AAmenuSelection == "Area")
		$filterSize = 1.5;
	else if ( $AAmenuSelection == "Tri")
		$filterSize = 2;
	else if ( $AAmenuSelection == "Lnczs")
		$filterSize = 2;
	else if ( $AAmenuSelection == "Sinc")
		$filterSize = 3;	
		else if ( $AAmenuSelection == "CatRm")
		$filterSize = 4;
		else if ( $AAmenuSelection == "Gauss")
		$filterSize = 1;
	else if ( $AAmenuSelection == "CkVar")
		$filterSize = 2.5;
		
setAttr vraySettings.aaFilterType $AA;
setAttr vraySettings.aaFilterSize $filterSize;

print ("AA set to " + ($AAmenuSelection) + " and filter size set to " + ($filterSize) + "\n");
}
//END ANTIALIASING CONTROLS

global proc optimizeSettings()
{
float $very = `getApplicationVersionAsFloat`;

int $memoryAmount;
int $memoryAmountNonGB;
if ($very != 2014)
	{
	float $memoryAmountFloat[] = `memory -phy`;
	$memoryAmountNonGB = $memoryAmountFloat[0];
	}
else if ($very == 2014)
	{
	float $textVersion;
	string $resultTextVersion = `promptDialog
    -title "Enter RAM amount"
    -message "Enter your total RAM amount in GB:"
    -button "OK" -button "Cancel" 
    -defaultButton "OK" -cancelButton "Cancel"
    -dismissString "Cancel"`;

	if ( $resultTextVersion == "OK" )
		{
		$memoryAmount = `promptDialog -query -text`;
		$memoryAmountNonGB = ($memoryAmount * 1024); 
		}
	}
setAttr vraySettings.sys_rayc_dynMemLimit ($memoryAmountNonGB * 0.8);
$threadCounter = `threadCount -q -n`;
int $drStatus = `getAttr "vraySettings.sys_distributed_rendering_on"`;

setAttr vraySettings.numPasses $threadCounter;
setAttr vraySettings.sys_max_threads $threadCounter;

if ($threadCounter > 4)
	{
	setAttr vraySettings.sys_regsgen_xc 32;
	}
if ($threadCounter > 8 || $drStatus == 1)
	{
	setAttr vraySettings.sys_regsgen_xc 16;
	}

////Dave's personal scene startup settings:
//setAttr "vraySettings.rt_subdivision" 1;
//setAttr "vraySettings.rt_displacement" 1;
//setAttr vraySettings.storeDirectLight 0;
//setAttr vraySettings.globopt_render_viewport_subdivision 1;
//setAttr vraySettings.samplerType 1;
//setAttr vraySettings.cmap_type 6;
//setAttr vraySettings.sys_regsgen_seqtype 3;
//setAttr "vraySettings.allowNegativeShaderColors" 1;
//setAttr "vraySettings.transferAssets" 1;
//setAttr "vraySettings.useCachedAssets" 1;

//end dave's personal settings

if (`getAttr "vraySettings.sys_distributed_rendering_on"`)
	{
	string $text;
	string $result = `promptDialog
    -title "Light Cache pass optimize"
    -message "Enter max hyperthreaded core count of single master/slave machines (not total core count):"
    -button "OK" -button "Cancel" 
    -defaultButton "OK" -cancelButton "Cancel"
    -dismissString "Cancel"`;

if ($result == "OK") 
	{
    $textinput = `promptDialog -query -text`;
	int $textIntput = $textinput;
	setAttr vraySettings.numPasses $textIntput ;
	}
else if ($result == "Cancel") 
	{
	warning "Light cache set to max core count of host machine.\n";
	}
	
}


}

global proc resChange()
{
$resmenuSelection = `optionMenuGrp -q -v resMenu`;
$fullResWidth = `getAttr defaultResolution.width`;
$fullResHeight = `getAttr defaultResolution.height`;
int $renderPercent;
float $setRenderWidth = `getAttr vraySettings.width`;
float $setRenderHeight = `getAttr vraySettings.height`;
float $renderPrintFactor;

if ( $resmenuSelection == "10%")
		{$renderPercent = 2;}
	else if ( $resmenuSelection == "25%")
		{$renderPercent = 3;}
	else if ( $resmenuSelection == "50%")
		{$renderPercent = 4;}
	else if ( $resmenuSelection == "75%")
		{$renderPercent = 5;}
	else if ( $resmenuSelection == "100%")
		{$renderPercent = 1;}
	else if ( $resmenuSelection == "110%")
		{$renderPercent = 6;}
	else if ( $resmenuSelection == "125%")
		{$renderPercent = 7;}
	else if ( $resmenuSelection == "150%")
		{$renderPercent = 8;}
	else if ( $resmenuSelection == "200%")
		{
		string $resultConfirm = `confirmDialog
			-title "Upres Warning"
			-message "Are you sure you want to double the actual scene resolution?"
			-button "OK" -button "Cancel" 
			-defaultButton "OK" -cancelButton "Cancel"
			-dismissString "Cancel"`;
		
		if ( $resultConfirm == "OK" )
			{
			setAttr "vraySettings.width" ($setRenderWidth * 2);
			setAttr "vraySettings.height" ($setRenderHeight * 2);
			setAttr defaultResolution.width ($fullResWidth * 2);
			setAttr defaultResolution.height ($fullResHeight * 2);
			$renderPercent = 200;
			vrayUpdateResolution();
			optionMenuGrp -e -v "100%" resMenu;
			}
		else  
			{
			warning "nothing done";
			}
		}

if ( $renderPercent == 2 )
		{$renderPrintFactor = 0.10;}
	else if ( $renderPercent == 3)
		{$renderPrintFactor = 0.25;}
	else if ( $renderPercent == 4)
		{$renderPrintFactor = 0.5;}
	else if ( $renderPercent == 5)
		{$renderPrintFactor = 0.75;}
	else if ( $renderPercent == 1)
		{$renderPrintFactor = 1.0;}	
	else if ( $renderPercent == 6)
		{$renderPrintFactor = 1.1;}
	else if ( $renderPercent == 7)
		{$renderPrintFactor = 1.25;}
	else if ( $renderPercent == 8)
		{$renderPrintFactor = 1.5;}
	else if ( $renderPercent == 200)
		{$renderPrintFactor = 2;}

$finalRenderWidth = ($fullResWidth * $renderPrintFactor);
$finalRenderHeight = ($fullResHeight * $renderPrintFactor);
$DaveBakeFinalRenderSize = (4096 * $renderPrintFactor);
if ( $resmenuSelection == "10%")
	{
	$DaveBakeFinalRenderSize = 512;
	}

setTestResolutionVar $renderPercent;
vrayUpdateResolution();

if ($renderPercent == 200) 
	{ 
	print ("Render resolution set to " + ($finalRenderWidth + " x " + $finalRenderHeight));
	}	 
else if (!($renderPercent == 200)) 
	{
	print ("Preview render resolution set to " + (($finalRenderWidth + " x " + $finalRenderHeight) + (". DaveBake420 will bake render at " + ($DaveBakeFinalRenderSize + " x " + $DaveBakeFinalRenderSize))));
	}
}
//END RESOLUTION CHANGE

//lightmap modes and feedback
global proc imMode0()
{
setAttr vraySettings.imap_mode 0;
warning "changed setting to Irradiance Map: Single Frame (uncached)";
}

global proc imMode1()
{
setAttr vraySettings.imap_mode 1;
warning "changed setting to Irradiance Map: Multi-frame incremental";
}

global proc imMode2()
{
setAttr vraySettings.imap_mode 2;
warning "changed setting to Irradiance Map: Single Frame (uncached)";
}

global proc imMode3()
{
setAttr vraySettings.imap_mode 3;
warning "changed setting to Irradiance Map: From File";
}

global proc imMode4()
{
setAttr vraySettings.imap_mode 4;
warning "changed setting to Irradiance Map: Add to Current Map";
}

global proc imMode5()
{
setAttr vraySettings.imap_mode 5;
warning "changed setting to Irradiance Map: Bucket Mode";
}

global proc imMode6()
{
setAttr vraySettings.imap_mode 6;
warning "changed setting to Irradiance Map: Animation (prepass)";
}

global proc imMode7()
{
setAttr vraySettings.imap_mode 7;
warning "changed setting to Irradiance Map: Animation (rendering)";
}

global proc lcMode0()
{
setAttr vraySettings.mode 0;
warning "changed setting to Light Cache: Single Frame (uncached)";
}

global proc lcMode1()
{
setAttr vraySettings.mode 1;
warning "changed setting to Light Cache: Fly-through";
}

global proc lcMode2()
{
setAttr vraySettings.mode 2;
warning "changed setting to Light Cache: From File";
}

global proc lcMode3()
{
setAttr vraySettings.mode 3;
warning "changed setting to Light Cache: Progressive Path Tracing";
}
//end lightmap modes and feedback


//INTERFACE HERE////////////////////////////////////////////////////////////
global proc vraytuner()
{
//automatically load V-Ray plug-in on script load if it's not loaded already
if (!(`pluginInfo -q -l vrayformaya`))
{
catchQuiet(`loadPlugin vrayformaya`);
}


if (`dockControl -exists VRayTuner`) {deleteUI VRayTuner;}

//if ( `window -exists vraytuna` )
//  deleteUI -window vraytuna;
string $myDC;
  
string $vraytunerdialogBoxWindow = `window -menuBar true vraytuna/* -title "V-Ray Tuner"
												 -rtf true */`;

//string $mySelection[] = `listRelatives -shapes`;
menu -label "Materials" -tearOff false;
				menuItem
					-label "Gamma Correct Me (.454 Gamma Node)"
					-ann "Adds a .454 Gamma Correction to selected texture (File, Ramp, etc)."
					-c "deGammaSwatchUI; repeatLast -ac \"deGammaSwatchUI;\"";
				menuItem
					-label "Material Threshold Fix"
					-ann "changes all V-Ray material thresholds to 0.002 for better rendering."
					-c "materialThresholder;";
				menuItem
					-label "Stored Texture Reloader"
					-ann "Select a file node and select this. Then select it with nothing selected to reload that file. Select a different file node to store that one."
					-c "storedTextureReload;";
				menuItem
					-label "Disable Texture Filtering for All Files"
					-ann "Opens all selected textures in your image editor."
					-c "disableTextureFiltering;";
				menuItem
					-label "Edit all selected textures"
					-ann "Opens all selected textures in your image editor."
					-c "editAllTextures;";
				menuItem
					-label "Select objects with selected materials"
					-ann "Selects the object, not just the faces, for the active selected material."
					-c "selectFromMats;";
				menuItem
					-label "Apply Better UV Checker material"
					-ann "Applies a Lambert mat with my UV grid image on it. Select objects and run it."
					-c "czecherMatTooVRT;";
				menuItem
					-label "Select file textures not in sourceimages"
					-ann "Selects the object, not just the faces, for the active selected material."
					-c "selectExternalSourceimages;";
				menuItem
					-label "Copy selected files to sourceimages and relink"
					-ann "Copies selected files to sourceimages and relinks them."
					-c "copyTexturerer;";
				menuItem
					-label "Select Missing Textures"
					-ann "Selects all File nodes that are not properly linked to file paths."
					-c "selectMissingTextures;";
				menuItem
					-label "Maya and Mental Ray Mat to V-Ray"
					-ann "Converts Maya and mental ray mia_x_passes materials to V-Ray Mat."
					-c "maya2VRay";
				menuItem
					-label "V-Ray/Maya Material swapper"
					-ann "Converts Maya Lambert/Blinn/Phong mats on selected object to V-Ray and vice-versa. Similar to above but more accurate, goes both ways and keeps old mat."
					-c "materialSwapper;";
				menuItem
					-label "Convert V-Ray (1.5) Material to MaxScript"
					-ann "Converts selected V-Ray material to a MaxScript command for Max/V-Ray 1.5"
					-c "vray15MatConverter";
				menuItem
					-label "Material Dropper"
					-ann "Takes V-Ray material from first selected object and applies to the rest of selected objects."
					-c "materialDropper";
				menuItem
					-label "Material Copy Dropper"
					-ann "Takes V-Ray material from first selected object and applies a duplicate shading network with unique sub-textures to each of the selected objects."
					-c "materialDropperCopy";
				menuItem
					-label "Lock Displacement to Object X Scale"
					-ann "Creates an expression to lock your object's displacement alpha gain/offset to it's X scale so you can scale objects without messing up displacement. Once your displacement is correct and tranforms are frozen, select mesh and run this."
					-c "displaceLocker";
				menuItem
					-label "Rename File Node With Filename"
					-ann "Renames selected hypershade File texture nodes with the actual file name, sans extension."
					-c "renameWithFilename";
				menuItem
					-label "Rename VRayMat with Filename_VRay"
					-ann "Renames selected hypershade VRayMat with the actual file name, sans extension + _VRay."
					-c "renameWithFilenameVray";
				menuItem
					-label "Shellac Me"
					-ann "Wraps the currently selected object's material in a Blendmat and Fresnel for clearcoats."
					-c "wrapInBlendFresnel";
				menuItem
					-label "Assign unique colour ID to all selected V-Ray materials or objects"
					-ann "Adds a unique colour ID to your materials for compositing. Select objects or V-Ray Mats and run script."
					-c "matIDMe";
				menuItem
					-label "Match all selected V-Ray material IDs to last selected material's ID"
					-ann "."
					-c "matIDMatcher";
				menuItem
					-label "Assign unique colour to all selected object's VRay Material diffuse colour"
					-ann "Nice for just randomizing colours for meshes. Needs a unique material for each object first."
					-c "uniqueColourMe";
				menuItem
					-label "Material Worker Layer"
					-annotation "Creates a temporary render layer to build material for use with V-Ray RT."
					-c "materialWorkerLayerUI";
						
		menu -label "Baking" -tearOff false;
				menuItem
					-label "Bake Window"
					-c "vrayShowBakeOptionsWindow";
				menuItem
					-label "Bake Options"
					-c "vrayShowDefaultBakeOptions";
				menuItem
					-label "DaveBake420"
					-annotation "This is my baking script that works with multiple objects. Will do Render Elements and names renders according to selected objects."
					-c "daveBakeUI";
				

menu -label "LightMaps" -tearOff false -pmc "lightMapsMenuBuilder" lightmapsMenuName;

menu -label "RT" -tearOff false -pmc "rtMenuBuilder" rtMenuName;

			setParent -menu ..;

menu -label "Utils" -tearOff false -pmc "utilitiesMenuBuilder" utilitiesMenuName;		
	
scrollLayout -cr true -w 279;
columnLayout;

//DOCKING CONTROLS//
string $myDC = `dockControl -area "left"
   -content $vraytunerdialogBoxWindow
   -allowedArea "left"
   -allowedArea "right" VRayTuner`;

//BUILD BUTTON TOOLS//
rowColumnLayout -numberOfColumns 6
        -columnWidth 1 45
        -columnWidth 2 45
        -columnWidth 3 38
        -columnWidth 4 38
        -columnWidth 5 38
        -columnWidth 6 45;
	
			checkBox -label "VFB" -ann "Use V-Ray Framebuffer" vraytunercheckbox;
			checkBox -label "LWF" -ann "Enable Linear Workflow" vraytunercheckbox2;
			checkBox -label "GI" -ann "Enable Global Illumination" vraytunercheckbox3;
			checkBox -label "Lk" -ann "Lock AA DMC samples to sampler threshold" vraytunercheckbox4;
			checkBox -label "SD" -ann "Store Direct Light for Light Cache" vraytunercheckbox5;
			checkBox -label "C" -ann "Clamp toggle" vraytunercheckbox6;

			checkBox -label "RE" -ann "Enable Render Elements. Toggles passes, V-Ray Dirt and stuff to save preview render time." vraytunercheckbox7;
			checkBox -label "DAC" -ann "Don't Affect Colours" vraytunercheckbox10;
			checkBox -label "Cs" -ann "Caustics" vraytunercheckbox9;
			checkBox -label "D" -ann "Enable Displacements" vraytunercheckbox8;
			checkBox -label "Eh" -ann "Enhance details" vraytunercheckbox11;
			checkBox -label "LCG" -ann "Light Cache For Glossy Rays" vraytunercheckbox12;

			checkBox -label "RVS" -ann "Render Viewport Subdivisions" vraytunercheckbox13;
			checkBox -label "SPM" -ann "Sub-pixel colour mapping" vraytunercheckbox14;
			checkBox -label "RC" -ann "Enable Reflective Caustics" vraytunercheckbox15;
			checkBox -label "TD" -ann "Time Dependent DMC" vraytunercheckbox16;
			checkBox -label "DR" -ann "Distributed Rendering" vraytunercheckbox17;
			checkBox -label "URT" -ann "Use Retrace Threshold" vraytunercheckbox18;
//Dave's personal
//V-Ray 3.4 only:
//			checkBox -label "xx" -ann "." vraytunercheckbox19;
//			checkBox -label "xx" -ann "." vraytunercheckbox20;
//			checkBox -label "xx" -ann "." vraytunercheckbox21;
//			checkBox -label "BG" -ann "Show BG texture in viewport" vraytunercheckbox22;
//			checkBox -label "LM" -ann "Use Local Machine for Distributed Rendering" vraytunercheckbox23;
//			checkBox -label "UCA" -ann "Use Cached Assets for Distributed Rendering" vraytunercheckbox24;
//end Dave's personal checkboxes
						
setParent ..;

	rowLayout -nc 6 -cw6 14 66 18 70 14 56;
		text -align left -label "GI:";
			optionMenuGrp -cc "readGI" -width 66 GImenu;
						
					menuItem -label "dunno";
					menuItem -d true;
					menuItem -label "IM/BF";
					menuItem -label "BF/LC"; 
	                menuItem -label "IM/LC";
 			        menuItem -label "BF/Ph";
					menuItem -label "BF/BF";
					menuItem -label "LC/LC";
					
text -align left -label "AA:";
optionMenuGrp -cc "AAcommand" -width 70 AAmenu; 
	                 menuItem -label "Box";
 			         menuItem -label "Area";
 			         menuItem -label "Tri";
 			         menuItem -label "Lnczs";
 			         menuItem -label "Sinc";
 			         menuItem -label "CatRm";
 			         menuItem -label "Gauss";
					 menuItem -label "CkVar";

text -align left -label "R%:";
optionMenuGrp -cc "resChange" -width 56 -ann "Preview Render resolution" resMenu; 
	                 menuItem -label "10%";
	                 menuItem -label "25%";
 			         menuItem -label "50%";
					 menuItem -label "75%";
					 menuItem -label "100%";
					 menuItem -label "110%";
					 menuItem -label "125%";
					 menuItem -label "150%";
					 menuItem -label "upres:";
					 menuItem -label "200%";
setParent ..;

rowLayout -nc 5 -cw5 48 48 48 48 48;


	button
		-label "VFB"
		-width 48
		-height 18
		-annotation "Only works after you've enabled VFB in options and render once. Not supported in OS X and Linux for <Maya 2011."
		-command "vray showVFB"
		;
		
	button
	-label "LWFMe"
	-width 48
	-height 18
	-annotation "Runs commands to work with linear gamma workflow. If you like to degamma each texture/colour node, hit this and then disable LWF above."
	-command "lwfMe()"
	;
		
	button
		-label "Refresh"
		-width 48
		-height 18
		-command "attachCommands"
		-ann "Refreshes and re-attaches sliders and toggles. Gives feedback about current primary/secondary GI schemes."
		;
		
	
	button
		-label "Settings"
		-width 48
		-height 18
		-command "unifiedRenderGlobalsWindow"
	;

	button
		-label "Render"
		-width 48
		-height 18
		-command "renderWithCheck"
		;
		
setParent ..;

rowLayout -nc 3 -cw3 82 82 82;


	button
		-label "Optimize"
		-width 82
		-height 18
		-annotation "This automatically sets your passes and core count, makes bucket size proportional to core count."
		-command "optimizeSettings"
	;

	button
		-label "DaveBake420"
		-width 82
		-height 18
		-annotation "This is my baking script that works with multiple objects. Will do Render Elements and names renders according to selected objects."
		-command "daveBakeUI"
	;
	
	button
		-label "Attach Cam"
		-width 82
		-height 18
		-command "connectCamExp()"
		-annotation "Connects Physical Camera sliders to camera's V-Ray attributes that you create first. Select your camera and hit the button."
	;	
	

setParent ..;
rowLayout -nc 3 -cw3 88 76 82;
		
		button
		-label "PerLightRender"
		-width 88
		-height 18
		-command "perLightRender();"
		; 
		
		button
		-label "Target Light"
		-width 76
		-height 18
		-ann "Aims selected V-Ray Rect Lights at object (select object first, then light)"
		-command "targetLight"
		; 
		
		button
		-label "Sun/Sky Me"
		-width 82
		-height 18
		-command "vrayCreateVRaySky; vrayCreateVRaySun;"

		-ann "This sets VRay light scales to 1 and sets the scale you had as their UV size. You shouldn't scale VRay lights so use this to scale them manually and then fix them."
		; 
		
//END BUTTONS
	
	setParent ..;
	separator -style "none" -h 2;
	setParent ..;
	
//BUILD SLIDERS AND COLLAPSIBLE FRAMES//

//DMC Globals
frameLayout -collapsable true -label "Global DMC Quality Control" -width 250;
columnLayout;
	text -align left -label "DMC Adaptive Amount:";
	floatSliderGrp -precision 2 -field 1 -min 0 -max 1 vraytunerslider1;
	
	text -align left -label "DMC Adaptive Threshold:";
	floatSliderGrp -field 1 -precision 3 -min 0.001 -max 0.02 vraytunerslider17; 

	text -align left -label "DMC Global Adaptive Min Samples:";
	intSliderGrp -field 1 -min 4 -max 32 vraytunerslider2;

	text -align left -label "DMC Global Subdivs Multiplier:";
	floatSliderGrp -precision 2 -field 1 -min .01 -max 10 vraytunerslider3;
setParent ..;
  setParent ..;
	
//AA 
frameLayout -collapsable true -label "DMC Antialiasing Controls" -width 250;
columnLayout;
					 
	text -align left -label "AA DMC Min Subdivs:";
	intSliderGrp -field 1 -min 1 -max 10 vraytunerslider4;
			
	text -align left -label "AA DMC Max Subdivs:";
	intSliderGrp -field 1 -min 1 -max 100 vraytunerslider5;
				
	text -align left -label "AA DMC Threshold (0.04 low, 0.004 hq):";
	floatSliderGrp -precision 3 -field 1 -min 0.001 -max 0.2 vraytunerslider6;
setParent ..;
setParent ..;

//GI stuff  
frameLayout -collapsable true -label "GI Primary and Secondary Controls" -width 250;
columnLayout;
	text -align left -label "Brute Force Subdivs:";
	intSliderGrp -field 1 -min 8 -max 50 vraytunerslider7;
	
	text -align left -label "Brute Force Bounces";
	intSliderGrp -field 1 -min 1 -max 20 vraytunerslider10;
	
	text -align left -label "Light Cache Subdivs:";
	intSliderGrp -field 1 -min 100 -max 10000 vraytunerslider9;
	
	text -align left -label "Light Cache Sample Size:";
	floatSliderGrp -precision 3 -field 1 -min 0 -max 0.5 vraytunerslider14;
	
	text -align left -label "Irradiance Map Quality (1 low, 7 hq):";
	intSliderGrp -field 1 -min 1 -max 7 vraytunerslider12;

//	text -align left -label "GI Contrast (GI Joe's Cousin):";
//	floatSliderGrp -precision 3 -field 1 -min 1 -max 2 vraytunerslider8;
	
//
setParent ..;
  setParent ..;	

//Physical Camera stuff  
frameLayout -collapsable true -label "Physical Camera (see Attach Camera)" -width 250;	
columnLayout;	
	text -align left -label "Physical Camera F-stop:";
	floatSliderGrp -precision 1 -field 1 -min 1 -max 32 vraytunerslider19;
	
	text -align left -label "Physical Camera ISO:";
	intSliderGrp -field 1 -min 1 -max 6400 vraytunerslider18;

	text -align left -label "Gamma (colour mapping):";
	floatSliderGrp -field 1 -precision 2 -min 0.1 -max 2.2 vraytunerslider15;

	text -align left -label "Overscan:";
	floatSliderGrp -field 1 -precision 3 -min 1 -max 2.2 -ann "V-Ray doesn't fit resolution gates vertically so increase Overscan to fill viewport height." vraytunerslider20;
//
setParent ..;
  setParent ..;	

//RT stuff  
frameLayout -collapsable true -label "V-Ray RT Settings" -width 250;	
columnLayout;		
	text -align left -label "RT max time (mins):";
	floatSliderGrp -field 1 -precision 2 -min 0.0 -max 10 vraytunerslider16;
	
	text -align left -label "RT max paths per pixel:";
	intSliderGrp -field 1 -min 4 -max 256 vraytunerslider21;
setParent ..;
  setParent ..;
  
//uncomment for older Maya versions
//showWindow $vraytunerdialogBoxWindow;

//CONNECT SLIDERS
attachCommands();
}


global proc attachCommands()
{
    $settings = ls("vraySettings");

    if (size($settings) == 1 && $settings[0] == "vraySettings")
    {
        if ( `attributeQuery -node vraySettings -exists "dmcs_adaptiveAmount"` )
        {
            connectControl vraytunerslider1 "vraySettings.dmcs_adaptiveAmount";
            connectControl vraytunerslider2 "vraySettings.dmcs_adaptiveMinSamples";
            connectControl vraytunerslider3 "vraySettings.dmcs_subdivsMult";
            connectControl vraytunerslider4 "vraySettings.dmcMinSubdivs";
            connectControl vraytunerslider5 "vraySettings.dmcMaxSubdivs";
            connectControl vraytunerslider6 "vraySettings.dmcThreshold";
            connectControl vraytunerslider7 "vraySettings.dmc_subdivs";
           // connectControl vraytunerslider8 "vraySettings.contrast";
            connectControl vraytunerslider9 "vraySettings.subdivs";
            connectControl vraytunerslider10 "vraySettings.dmc_depth";
            connectControl vraytunerslider12 "vraySettings.imap_currentPreset";
            connectControl vraytunerslider14 "vraySettings.sampleSize";
            connectControl vraytunerslider15 "vraySettings.cmap_gamma";
            connectControl vraytunerslider16 "vraySettings.rt_maxRenderTime";
 	        connectControl vraytunerslider21 "vraySettings.rt_maxPathsPerPixel";  

            connectControl vraytunerslider17 "vraySettings.dmcs_adaptiveThreshold";

            connectControl vraytunercheckbox "vraySettings.vfbOn";
            connectControl vraytunercheckbox2 "vraySettings.cmap_linearworkflow";
            connectControl vraytunercheckbox3 "vraySettings.giOn";
            connectControl vraytunercheckbox4 "vraySettings.dmcLockThreshold";
            connectControl vraytunercheckbox5 "vraySettings.storeDirectLight";
            connectControl vraytunercheckbox6 "vraySettings.cmap_clampOutput";
            connectControl vraytunercheckbox7 "vraySettings.relements_enableall";
            connectControl vraytunercheckbox8 "vraySettings.globopt_geom_displacement";

            connectControl vraytunercheckbox9 "vraySettings.causticsOn";
            connectControl vraytunercheckbox10 "vraySettings.cmap_adaptationOnly";
            connectControl vraytunercheckbox11 "vraySettings.imap_detailEnhancement";
            connectControl vraytunercheckbox12 "vraySettings.useForGlossy";
            connectControl vraytunercheckbox13 "vraySettings.globopt_render_viewport_subdivision";
            connectControl vraytunercheckbox14 "vraySettings.cmap_subpixelMapping";
            connectControl vraytunercheckbox15 "vraySettings.reflectiveCaustics";
            connectControl vraytunercheckbox16 "vraySettings.dmcs_timeDependent";
            connectControl vraytunercheckbox17 "vraySettings.sys_distributed_rendering_on";//setAttr \"vraySettings.sys_distributed_rendering_on\" 1;
            connectControl vraytunercheckbox18 "vraySettings.useRetraceThreshold";
//			connectControl vraytunercheckbox19 ;
//			connectControl vraytunercheckbox20 ; 
//			connectControl vraytunercheckbox21 ;
//Dave's personal for V-Ray 2.4
//			connectControl vraytunercheckbox22 "vraySettings.cam_viewportTexEnable"; 
//			connectControl vraytunercheckbox23 "vraySettings.sys_distributed_rendering_local";
//			connectControl vraytunercheckbox24 "vraySettings.useCachedAssets";
//end Dave's personal
            //connect render percentage to popup
            int $currentRes = `optionVar -q renderViewTestResolution`;

            if ( $currentRes == 1)
            	optionMenuGrp -edit -value "100%" resMenu;

            else if ( $currentRes == 2)
            	optionMenuGrp -edit -value "10%" resMenu;

            else if ( $currentRes == 3)
            	optionMenuGrp -edit -value "25%" resMenu;

            else if ( $currentRes == 4)
            	optionMenuGrp -edit -value "50%" resMenu;

            else if ( $currentRes == 5)
            	optionMenuGrp -edit -value "75%" resMenu;

            else if ( $currentRes == 6)
            	optionMenuGrp -edit -value "110%" resMenu;

            else if ( $currentRes == 7)
            	optionMenuGrp -edit -value "125%" resMenu;

            else if ( $currentRes == 8)
            	optionMenuGrp -edit -value "150%" resMenu;
			
            //connect AA setting
            int $currentlyActiveAA = `getAttr vraySettings.aaFilterType`;

            if ( $currentlyActiveAA == 0)
            	optionMenuGrp -edit -value "Box" AAmenu;

            else if ( $currentlyActiveAA == 1)
            	optionMenuGrp -edit -value "Area" AAmenu;

            else if ( $currentlyActiveAA == 2)
            	optionMenuGrp -edit -value "Tri" AAmenu;

            else if ( $currentlyActiveAA == 3)
            	optionMenuGrp -edit -value "Lnczs" AAmenu;

            else if ( $currentlyActiveAA == 4)
            	optionMenuGrp -edit -value "Sinc" AAmenu;

            else if ( $currentlyActiveAA == 5)
            	optionMenuGrp -edit -value "CatRm" AAmenu;

            else if ( $currentlyActiveAA == 6)
            	optionMenuGrp -edit -value "Gauss" AAmenu;

            else if ( $currentlyActiveAA == 7)
            	optionMenuGrp -edit -value "CkVar" AAmenu;
      
      //connect GI menu to configuration
    	int $currentGIPrimary = `getAttr vraySettings.primaryEngine`;
		int $currentGISecondary = `getAttr vraySettings.secondaryEngine`;
		
        if ( $currentGIPrimary == 2 && $currentGISecondary == 3)
        optionMenuGrp -edit -value "BF/LC" GImenu;
		
		else if ( $currentGIPrimary == 0 && $currentGISecondary == 2)
        optionMenuGrp -edit -value "IM/BF" GImenu;
      	
      	else if ( $currentGIPrimary == 0 && $currentGISecondary == 3)
        optionMenuGrp -edit -value "IM/LC" GImenu;
        
        else if ( $currentGIPrimary == 2 && $currentGISecondary == 1)
        optionMenuGrp -edit -value "BF/Ph" GImenu;
        
        else if ( $currentGIPrimary == 2 && $currentGISecondary == 2)
        optionMenuGrp -edit -value "BF/BF" GImenu;
        
        else if ( $currentGIPrimary == 3 && $currentGISecondary == 3)
        optionMenuGrp -edit -value "LC/LC" GImenu;
        
        else 
        optionMenuGrp -edit -value "dunno" GImenu;
        
            printVRayInfo();
        }
    }
	else
    {

		warning "Hit Refresh after you've set V-Ray as your renderer and initialized V-Ray by rendering or adding any V-Ray node.\n";
    }

}
//END OF ATTACH COMMANDS