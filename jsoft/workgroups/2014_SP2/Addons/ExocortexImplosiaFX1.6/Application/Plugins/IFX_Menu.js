// New Plugin
// Initial code generated by Softimage SDK Wizard
// Executed Wed Feb 1 00:51:44 UTC+0200 2012 by Core
// 
// Tip: To add a command to this plug-in, right-click in the 
// script editor and choose Tools > Add Command.

function XSILoadPlugin( in_reg )
{
	in_reg.Author = "Oleg Bliznuk";
	in_reg.Name = "IFX_MenuItem";
	in_reg.Email = "gbotfx@gmail.com";
	in_reg.URL = "http://www.exocortex.com";
	in_reg.Major = 1;
	in_reg.Minor = 0;

    // Register a single Menu entry point on the Help menu
	in_reg.RegisterMenu( siMenuMainTopLevelID   , "IFX" );
	//RegistrationInsertionPoint - do not remove this line

	return true;
}

function XSIUnloadPlugin( in_reg )
{
	var strPluginName;
	strPluginName = in_reg.Name;
	Application.LogMessage(strPluginName + " has been unloaded.",siVerbose);
	return true;
}

////////////
function IFX_Init( in_context )
{
	// Get the menu object from the Context input
	var oTopMnu = in_context.Source;

	// Add the submenu item
	var oPrePro = oTopMnu.AddItem( "Mesh Pre-processing",
		siMenuItemSubmenu )
		oTopMnu.AddSeparatorItem();
	var oActPro = oTopMnu.AddItem( "Shatter",
		siMenuItemSubmenu )
		oTopMnu.AddSeparatorItem();
		//
		oTopMnu.AddCallbackItem( "Boolean", "ifx_appCSG" );
		oTopMnu.AddSeparatorItem();
	//
	oTopMnu.AddCallbackItem( "Apply Cached Data", "ifx_appCacheData" );
	oTopMnu.AddSeparatorItem();
	//
	var oPostPro = oTopMnu.AddItem( "Mesh Post-processing",
		siMenuItemSubmenu )
		
	// add subs to preprocessing level
	oPrePro.AddCallbackItem( "Cap Holes", "ifx_capHoles" );
	oPrePro.AddCallbackItem( "Triangulate", "ifx_triangulate" );
    oPrePro.AddCallbackItem( "Freeze", "ifx_freeze" );

    // add subs to processing
	oActPro.AddCallbackItem( "Iterative", "ifx_iterFR" );
	oActPro.AddCallbackItem( "Continuous", "ifx_contFR" );
    oActPro.AddCallbackItem( "Voronoi", "ifx_voroFR" );
	
	// add subs to postprocessing
	oPostPro.AddCallbackItem( "Material to interior", "ifx_mat2in" );
	oPostPro.AddCallbackItem( "Material to exterior", "ifx_mat2ext" );
    oPostPro.AddCallbackItem( "Correct Normals", "ifx_correctNorms" );
	oPostPro.AddCallbackItem( "Extract Chunks", "ifx_extractIsl" );
	oPostPro.AddCallbackItem( "Select interior faces", "ifx_selIn" );
	
	return true;
}


// define funcs

function ifx_appCacheData ( in_ctxt )
{
    var slctGlob = Application.Selection;
Application.LogMessage ( "Total fractured objects count: "+slctGlob.count );
for (var c1=0;c1<slctGlob.count;c1++)
{
var slct = slctGlob(c1);
if ((slct != null) && ( slct.Type.toString() == "polymsh"))
{
  Application.ApplyOp("ICETree", slct , "siNode", "", "", 0);
  var lastTree = slct.ActivePrimitive.ICETrees(0);
  Application.SetValue(String(lastTree)+".Name", "applyMatData_tree", "");
  Application.AddICECompoundNode("IFX Apply Passed Data", String(lastTree)+".Name");
  Application.ConnectICENodes(String(lastTree)+".port1", String(lastTree)+".IFX_Apply_Passed_Data.Perform");
  Application.InspectObj(String(lastTree)+".IFX_Apply_Passed_Data");
}
else
  Application.LogMessage ( "Non-poly object encountered, bypassed!" , siWarningMsg );
};
    return true;
};

//
function ifx_capHoles ( in_ctxt )
{
var slctGlob = Application.Selection;
Application.LogMessage ( "Total objects count to capping: "+slctGlob.count );
for (var c1=0;c1<slctGlob.count;c1++)
{
var slct = slctGlob(c1);
if ((slct != null) && ( slct.Type.toString() == "polymsh"))
{
  Application.ApplyOp("ICETree", slct , "siNode", "", "", 0)
  var lastTree = slct.ActivePrimitive.ICETrees(0);
  Application.SetValue(String(lastTree)+".Name", "CapAllHoles_tree", "");
  Application.AddICECompoundNode("IFX Cap All Holes", String(lastTree)+".Name")
  Application.ConnectICENodes(String(lastTree)+".port1", String(lastTree)+".IFX_Cap_All_Holes.Perform")
  Application.InspectObj(String(lastTree)+".IFX_Cap_All_Holes")
} 
else
  Application.LogMessage ( "Non-poly object encountered, bypassed!", siWarningMsg );
};
    return true;
};
//
function ifx_triangulate( in_ctxt )
{
var slctGlob = Application.Selection;
Application.LogMessage ( "Total objects count to triangulation: "+slctGlob.count );
for (var c1=0;c1<slctGlob.count;c1++)
{
var slct = slctGlob(c1);
if ((slct != null) && ( slct.Type.toString() == "polymsh"))
  Application.ApplyTopoOp("TriangulatePolygons", slct, "siUnspecified", "siPersistentOperation", "");
else
  Application.LogMessage ( "Non-poly object encountered, bypassed!", siWarningMsg );
};
    return true;
};
//
function ifx_freeze ( in_ctxt )
{
Application.FreezeObj("", "", "")
    return true;
};
//
function ifx_iterFR ( in_ctxt )
{
var slctGlob = Application.Selection;
Application.LogMessage ( "Total objects count to fracture: "+slctGlob.count );
for (var c1=0;c1<slctGlob.count;c1++)
{
var slct = slctGlob(c1);
if ((slct != null) && ( slct.Type.toString() == "polymsh"))
{
  Application.ApplyOp("ICETree", slct , "siNode", "", "", 0)
  var lastTree = slct.ActivePrimitive.ICETrees(0);
  Application.SetValue(String(lastTree)+".Name", "IterativeFRACTURE_tree", "");
  Application.AddICECompoundNode("IFX Iterative Fracture", String(lastTree)+".Name")
  Application.ConnectICENodes(String(lastTree)+".port1", String(lastTree)+".IFX_Iterative_Fracture.Perform")
  Application.InspectObj(String(lastTree)+".IFX_Iterative_Fracture")
} 
else
  Application.LogMessage ( "Non-poly object encountered, bypassed!", siWarningMsg );
};
    return true;
};
//
function ifx_contFR ( in_ctxt )
{
var slctGlob = Application.Selection;
Application.LogMessage ( "Total objects count to fracture: "+slctGlob.count );
for (var c1=0;c1<slctGlob.count;c1++)
{
var slct = slctGlob(c1);
if ((slct != null) && ( slct.Type.toString() == "polymsh"))
{
  Application.ApplyOp("ICETree", slct , "siNode", "", "", 0)
  var lastTree = slct.ActivePrimitive.ICETrees(0);
  Application.SetValue(String(lastTree)+".Name", "ContinuousFRACTURE_tree", "");
  Application.AddICECompoundNode("IFX Continuous Fracture", String(lastTree)+".Name")
  Application.ConnectICENodes(String(lastTree)+".port1", String(lastTree)+".IFX_Continuous_Fracture.Perform")
  Application.InspectObj(String(lastTree)+".IFX_Continuous_Fracture")
} 
else
  Application.LogMessage ( "Non-poly object encountered, bypassed!", siWarningMsg );
};
    return true;
};
//
function ifx_voroFR ( in_ctxt )
{
var slctGlob = Application.Selection;
Application.LogMessage ( "Total objects count to fracture: "+slctGlob.count );
for (var c1=0;c1<slctGlob.count;c1++)
{
var slct = slctGlob(c1);
if ((slct != null) && ( slct.Type.toString() == "polymsh"))
{
  Application.ApplyOp("ICETree", slct , "siNode", "", "", 0)
  var lastTree = slct.ActivePrimitive.ICETrees(0);
  Application.SetValue(String(lastTree)+".Name", "VoronoiFRACTURE_tree", "");
  Application.AddICECompoundNode("IFX Voronoi Fracture", String(lastTree)+".Name")
  Application.ConnectICENodes(String(lastTree)+".port1", String(lastTree)+".IFX_Voronoi_Fracture.Perform")
  Application.InspectObj(String(lastTree)+".IFX_Voronoi_Fracture")
} 
else
  Application.LogMessage ( "Non-poly object encountered, bypassed!", siWarningMsg );
};
    return true;
};
//
function ifx_mat2in ( in_ctxt )
{
// interior
slct_poly = Application.Selection(0)
slct_mat = Application.Selection(1)

if ((slct_poly != null) && ( slct_poly.Type.toString() == "polymsh") && (slct_mat != null) && ( slct_mat.Type.toString() == "material"))
{
var attr = slct_poly.ActivePrimitive.Geometry.GetICEAttributeFromName("MaterialID");
var mat_id = new VBArray( attr.DataArray ).toArray();
if ( mat_id.length != 0 )
{

var f_a =[];
var s_a =[];
var f_m = mat_id[0];
var s_m = mat_id[0];
var c1 = 0;
while ( f_m == s_m )
{
   s_m = mat_id[c1];
   c1++;
}
if ( f_m < s_m ) { s_m -= f_m; f_m += s_m; s_m = f_m - s_m; } else f_m = f_m;
 
for(var i=0; i < mat_id.length; i++)
   mat_id[i] == f_m ?  f_a.push (i) : s_a.push(i);

SetPolygonSelectionFilter();
CopyPaste(slct_mat, null, slct_poly+".poly["+f_a+"]", 1);
ActivateObjectSelTool(null);
}
else
Application.LogMessage ( "Material ID data not founded! Check for 'Apply Cached Data' compound applied!",siErrorMsg );
}
else
Application.LogMessage ( "Please, select a polymesh first and after that a material!" , siWarningMsg);
    return true;
};
//
function ifx_mat2ext ( in_ctxt )
{
// exterior
slct_poly = Application.Selection(0)
slct_mat = Application.Selection(1)

if ((slct_poly != null) && ( slct_poly.Type.toString() == "polymsh") && (slct_mat != null) && ( slct_mat.Type.toString() == "material"))
{
var attr = slct_poly.ActivePrimitive.Geometry.GetICEAttributeFromName("MaterialID");
var mat_id = new VBArray( attr.DataArray ).toArray();
if ( mat_id.length != 0 )
{

var f_a =[];
var s_a =[];
var f_m = mat_id[0];
var s_m = mat_id[0];
var c1 = 0;
while ( f_m == s_m )
{
   s_m = mat_id[c1];
   c1++;
}
if ( f_m < s_m ) { s_m -= f_m; f_m += s_m; s_m = f_m - s_m; } else f_m = f_m;
 
for(var i=0; i < mat_id.length; i++)
   mat_id[i] == f_m ?  f_a.push (i) : s_a.push(i);

SetPolygonSelectionFilter();
CopyPaste(slct_mat, null, slct_poly+".poly["+s_a+"]", 1);
ActivateObjectSelTool(null);
}
else
Application.LogMessage ( "Material ID data not founded! Check for 'Apply Cached Data' compound applied!" ,siErrorMsg );
}
else
Application.LogMessage ( "Please, select a polymesh first and after that a material!", siWarningMsg);
    return true;
};
//
function ifx_correctNorms ( in_ctxt )
{
function GetName ( _index, _slct )
{
var allNames = _slct.GetAsText();
var actualChar = allNames.charAt(0) + ",";
var chcnt = 0;
var seekBegin = 0;
var seekEnd = 0;
var actIndx = 0;
var result = "empty";
while ( actualChar != "," && chcnt < allNames.length )
  {
    chcnt++;
    actualChar = allNames.charAt(chcnt);
    if ( actualChar == "," || chcnt == allNames.length ) { if(actIndx == _index ) { seekEnd = chcnt ; break;}; else { actIndx++; actualChar = "a";  seekBegin = chcnt + 1; }; };
  };

      result = "";
      while ( seekBegin < seekEnd ) 
	  {
	     result += allNames.charAt(seekBegin);
	     seekBegin++;
      };
	  return result;
	  
  Application.LogMessage ( "Error During parsing name udner model" , siErrorMsg);
  return "";
};




var slctGlob = Application.Selection;
Application.LogMessage ( "Total objects count: "+slctGlob.count );
for (var cg=0;cg<slctGlob.count;cg++)
{



Application.LogMessage ("obj index="+cg);
Application.LogMessage ( GetName(cg, slctGlob));


var slct = slctGlob(cg);
if ((slct != null) && ( slct.Type.toString() == "polymsh"))
{

  SetUserNormalValues ( GetName(cg, slctGlob) ,[0], [0,0,0] );
  var attrs = slct.ActivePrimitive.Geometry.ICEAttributes;
  var IsFound = false;
  var c1 =0;
  while ( c1<attrs.count )
  {
     if ( attrs(c1).Name == "IFX_NORMALS_CONTAINER" ) { IsFound = true; c1 = attrs.count; } else {c1++; continue}  ;
  };
    if ( IsFound )
    {
	  
    var attr = slct.ActivePrimitive.Geometry.GetICEAttributeFromName("IFX_NORMALS_CONTAINER");
	if ( attr.StructureType != 2 ) { Application.LogMessage ("Normals attribute is invalid, canceled" ,siErrorMsg ); continue; };
    var accessorGlob = new VBArray( attr.DataArray2D ).toArray();
	  var accessorSub = new VBArray( accessorGlob[0] ).toArray();
      if ( accessorSub.length != 0)
        {
           var normIndices = [];
		   var normValues = [];
           for(var i=0; i < accessorSub.length; i++)
            {
			 normIndices.push(i) ;
			 normValues.push ( accessorSub[i].x );
			 normValues.push ( accessorSub[i].y );
			 normValues.push ( accessorSub[i].z );	     
            };
			SetUserNormalValues ( GetName(cg, slctGlob) ,normIndices, normValues );
         } 
      else
         {
            Application.LogMessage ( "Normals data not found! Check for 'Apply Cached Data' compound applied!" , siErrorMsg );
         };
     };
  else
  {
  Application.LogMessage ( "Normals data not found! Check for 'Apply Cached Data' compound applied!" , siErrorMsg );
  };
}
else
   Application.LogMessage ( "Non-poly object encountered, bypassed!", siWarningMsg );

};
  

    return true;
};
//
function ifx_extractIsl ( in_ctxt )
{
var slct_poly = Application.Selection(0);
var validExe = true;
  if ((slct_poly != null) && ( slct_poly.Type.toString() == "polymsh"))
  {

  try { var attr = slct_poly.ActivePrimitive.Geometry.GetICEAttributeFromName("IFX_PolyIslandID"); }
  catch (e) {  Application.LogMessage ("Islands ID attribute is invalid, canceled" ,siErrorMsg ); validExe = false; }
  if( validExe )
  {
  if ( attr.StructureType != 2 ) { Application.LogMessage ("Islands ID attribute is invalid, canceled" ,siErrorMsg ); };
  var temp = new VBArray( attr.DataArray2D ).toArray();
  var isl_id = new VBArray( temp[0] ).toArray();

  var actualChunkName = "GIGACHUNK";
  var counter = 0, a = 0, a_prev =0 , c2=0;
  var filler = [];
  var list2add = [];
  a_prev = isl_id[0].y; 
  a = isl_id[1].y; 

  //
  var progress = XSIUIToolkit.ProgressBar;
  progress.Maximum = isl_id[0].y;
  progress.Step = 1
  progress.Caption = "Extraction Progress"
  progress.CancelEnabled = true;
  progress.Visible = true;
  //
  
  for (var counter = 0 ; counter < isl_id.length-1 ; )
  {
   if ( a == a_prev ) 
   { 
      filler.push (isl_id[counter].x); 
   } 
   else
   {
      actualChunkName = slct_poly+"_IFX_chunk_"+c2;
      Application.ExtractFromComponents("ExtractPolygonsOp", slct_poly+".poly" + "["+filler+"]", actualChunkName); 
	  FreezeObj( actualChunkName , "","" );
	  list2add.push (actualChunkName );
      filler.length = 0; 
	  c2++;
	  progress.Increment();
	  filler.push (isl_id[counter].x); 
   }; 
   a_prev = a;
   counter++; 
   a = isl_id[counter].y; 
   if ( progress.CancelPressed == true ) break;
  }
  //
  a = 0; a_prev =1;  filler.length = 0;
  a = isl_id[isl_id.length-a_prev].y;
  while ( a == 0 )
  {
     filler.push(isl_id[isl_id.length-a_prev].x);
     a_prev++;
     a = isl_id[isl_id.length-a_prev].y;
  }
  
  actualChunkName = slct_poly+"_IFX_chunk_"+c2;
  Application.ExtractFromComponents("ExtractPolygonsOp", slct_poly+".poly" + "["+filler+"]", actualChunkName);
  FreezeObj( actualChunkName , "","" );
  list2add.push (actualChunkName );
  CreateGroup( slct_poly+"_CHUNKS_GRP", list2add, null );
  Application.Logmessage ( "Chunks: " + c2 );
  Application.Logmessage ( ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>"); 
 progress.Visible = false;
 }
 else
 {
  Application.LogMessage ( "Could not find IslandID attribute! Check for 'Apply Cached Data' compound applied!", siErrorMsg );
}
  }
  else
  {
    Application.LogMessage ( "Non-poly object encountered, bypassed!", siWarningMsg );
  };

    return true;
};
//
function ifx_selIn ( in_ctxt )
{
// interior
slct_poly = Application.Selection(0)

if ((slct_poly != null) && ( slct_poly.Type.toString() == "polymsh") )
{
var attr = slct_poly.ActivePrimitive.Geometry.GetICEAttributeFromName("MaterialID");
var mat_id = new VBArray( attr.DataArray ).toArray();
if ( mat_id.length != 0 )
{

var f_a =[];
var s_a =[];
var f_m = mat_id[0];
var s_m = mat_id[0];
var c1 = 0;
while ( f_m == s_m )
{
   s_m = mat_id[c1];
   c1++;
}
if ( f_m < s_m ) { s_m -= f_m; f_m += s_m; s_m = f_m - s_m; } else f_m = f_m;
 
for(var i=0; i < mat_id.length; i++)
   mat_id[i] == f_m ?  f_a.push (i) : s_a.push(i);

SetPolygonSelectionFilter();
SelectGeometryComponents(slct_poly+".poly["+f_a+"]"); 
}
else
Application.LogMessage ( "Material ID data not founded!",siErrorMsg );
}
else
Application.LogMessage ( "Please, select a polymesh!" , siWarningMsg);
    return true;
};
//


function ifx_appCSG ( in_ctxt )
{
    
slctGlobal = Application.Selection;

slct_A = slctGlobal(0);
slct_B = slctGlobal(1);
slct_R = slctGlobal(2);

if ((slct_A != null) && ( slct_A.Type.toString() == "polymsh") && (slct_B != null) && ( slct_B.Type.toString() == "polymsh") && (slctGlobal.count == 2 || (slctGlobal.count == 3 &&((slct_R != null) && ( slct_R.Type.toString() == "polymsh") ))))
{
   var mode = slctGlobal.count == 3 ? true : false;
   Application.Logmessage ( mode );
   if ( mode )
   {
   // use third selection item as result
       Application.ApplyOp("ICETree", slct_R , "siNode", "", "", 0);
	   var lastTree = slct_R.ActivePrimitive.ICETrees(0);
	   Application.SetValue(String(lastTree)+".Name", "BooleanCSG_tree", "");
	   Application.AddICECompoundNode("IFX Gigaboolean", String(lastTree)+".Name");
	   Application.ConnectICENodes(String(lastTree)+".port1", String(lastTree)+".IFX_Gigaboolean.Perform");
	   //
	   AddICENode("GetDataNode", String(lastTree));
	   AddICENode("GetDataNode", String(lastTree));
       SetValue( String(lastTree) + ".SceneReferenceNode.reference" , String(slct_A), null);    
       SetValue( String(lastTree) + ".SceneReferenceNode[1].reference" , String(slct_B), null);    
	   ConnectICENodes(String(lastTree) + ".IFX_GigaBoolean.A_Geo",String(lastTree) +".SceneReferenceNode.outname" );
	   ConnectICENodes(String(lastTree) + ".IFX_GigaBoolean.B_Geo",String(lastTree) +".SceneReferenceNode[1].outname" );
	   Application.InspectObj(String(lastTree)+".IFX_Gigaboolean");	   	   
   }
   else
   { // use A selection item as result
       Application.ApplyOp("ICETree", slct_A , "siNode", "", "", 0);
	   var lastTree = slct_A.ActivePrimitive.ICETrees(0);
	   Application.SetValue(String(lastTree)+".Name", "BooleanCSG_tree", "");
	   Application.AddICECompoundNode("IFX Gigaboolean", String(lastTree)+".Name");
	   Application.ConnectICENodes(String(lastTree)+".port1", String(lastTree)+".IFX_Gigaboolean.Perform");
	   //
	   AddICENode("GetDataNode", String(lastTree));
	   AddICENode("GetDataNode", String(lastTree));
       SetValue( String(lastTree) + ".SceneReferenceNode.reference" , String(slct_A), null);    
       SetValue( String(lastTree) + ".SceneReferenceNode[1].reference" , String(slct_B), null);    
	   ConnectICENodes(String(lastTree) + ".IFX_GigaBoolean.A_Geo",String(lastTree) +".SceneReferenceNode.outname" );
	   ConnectICENodes(String(lastTree) + ".IFX_GigaBoolean.B_Geo",String(lastTree) +".SceneReferenceNode[1].outname" );
	   Application.InspectObj(String(lastTree)+".IFX_Gigaboolean");	   	   
   }
} 
else
  Application.LogMessage ( "Non-poly object encountered, bypassed!", siWarningMsg );

    return true;
};
//















